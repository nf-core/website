{"ast":null,"code":"'use strict';\n/* Dependencies. */\n\nvar extend = require('extend');\n\nvar bail = require('bail');\n\nvar vfile = require('vfile');\n\nvar trough = require('trough');\n\nvar string = require('x-is-string');\n\nvar plain = require('is-plain-obj');\n/* Expose a frozen processor. */\n\n\nmodule.exports = unified().freeze();\nvar slice = [].slice;\nvar own = {}.hasOwnProperty;\n/* Process pipeline. */\n\nvar pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file);\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done);\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err);\n    } else {\n      ctx.tree = tree;\n      ctx.file = file;\n      next();\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file);\n}\n/* Function to create the first processor. */\n\n\nfunction unified() {\n  var attachers = [];\n  var transformers = trough();\n  var namespace = {};\n  var frozen = false;\n  var freezeIndex = -1;\n  /* Data management. */\n\n  processor.data = data;\n  /* Lock. */\n\n  processor.freeze = freeze;\n  /* Plug-ins. */\n\n  processor.attachers = attachers;\n  processor.use = use;\n  /* API. */\n\n  processor.parse = parse;\n  processor.stringify = stringify;\n  processor.run = run;\n  processor.runSync = runSync;\n  processor.process = process;\n  processor.processSync = processSync;\n  /* Expose. */\n\n  return processor;\n  /* Create a new processor based on the processor\n   * in the current scope. */\n\n  function processor() {\n    var destination = unified();\n    var length = attachers.length;\n    var index = -1;\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index]);\n    }\n\n    destination.data(extend(true, {}, namespace));\n    return destination;\n  }\n  /* Freeze: used to signal a processor that has finished\n   * configuration.\n   *\n   * For example, take unified itself.  It’s frozen.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be extended, by invoking it, before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor. */\n\n\n  function freeze() {\n    var values;\n    var plugin;\n    var options;\n    var transformer;\n\n    if (frozen) {\n      return processor;\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex];\n      plugin = values[0];\n      options = values[1];\n      transformer = null;\n\n      if (options === false) {\n        continue;\n      }\n\n      if (options === true) {\n        values[1] = undefined;\n      }\n\n      transformer = plugin.apply(processor, values.slice(1));\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer);\n      }\n    }\n\n    frozen = true;\n    freezeIndex = Infinity;\n    return processor;\n  }\n  /* Data management.\n   * Getter / setter for processor-specific informtion. */\n\n\n  function data(key, value) {\n    if (string(key)) {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen);\n        namespace[key] = value;\n        return processor;\n      }\n      /* Get `key`. */\n\n\n      return own.call(namespace, key) && namespace[key] || null;\n    }\n    /* Set space. */\n\n\n    if (key) {\n      assertUnfrozen('data', frozen);\n      namespace = key;\n      return processor;\n    }\n    /* Get space. */\n\n\n    return namespace;\n  }\n  /* Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a preset,\n   * *   a list of presets, attachers, and arguments (list\n   *     of attachers and options). */\n\n\n  function use(value) {\n    var settings;\n    assertUnfrozen('use', frozen);\n\n    if (value === null || value === undefined) {\n      /* Empty */\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments);\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value);\n      } else {\n        addPreset(value);\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`');\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings);\n    }\n\n    return processor;\n\n    function addPreset(result) {\n      addList(result.plugins);\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings);\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value);\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value);\n        } else {\n          addPreset(value);\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`');\n      }\n    }\n\n    function addList(plugins) {\n      var length;\n      var index;\n\n      if (plugins === null || plugins === undefined) {\n        /* Empty */\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length;\n        index = -1;\n\n        while (++index < length) {\n          add(plugins[index]);\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`');\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin);\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value);\n        }\n\n        entry[1] = value;\n      } else {\n        attachers.push(slice.call(arguments));\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length;\n    var index = -1;\n    var entry;\n\n    while (++index < length) {\n      entry = attachers[index];\n\n      if (entry[0] === plugin) {\n        return entry;\n      }\n    }\n  }\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor. */\n\n\n  function parse(doc) {\n    var file = vfile(doc);\n    var Parser;\n    freeze();\n    Parser = processor.Parser;\n    assertParser('parse', Parser);\n\n    if (newable(Parser)) {\n      return new Parser(String(file), file).parse();\n    }\n\n    return Parser(String(file), file); // eslint-disable-line new-cap\n  }\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), async. */\n\n\n  function run(node, file, cb) {\n    assertNode(node);\n    freeze();\n\n    if (!cb && typeof file === 'function') {\n      cb = file;\n      file = null;\n    }\n\n    if (!cb) {\n      return new Promise(executor);\n    }\n\n    executor(null, cb);\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done);\n\n      function done(err, tree, file) {\n        tree = tree || node;\n\n        if (err) {\n          reject(err);\n        } else if (resolve) {\n          resolve(tree);\n        } else {\n          cb(null, tree, file);\n        }\n      }\n    }\n  }\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), sync. */\n\n\n  function runSync(node, file) {\n    var complete = false;\n    var result;\n    run(node, file, done);\n    assertDone('runSync', 'run', complete);\n    return result;\n\n    function done(err, tree) {\n      complete = true;\n      bail(err);\n      result = tree;\n    }\n  }\n  /* Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor. */\n\n\n  function stringify(node, doc) {\n    var file = vfile(doc);\n    var Compiler;\n    freeze();\n    Compiler = processor.Compiler;\n    assertCompiler('stringify', Compiler);\n    assertNode(node);\n\n    if (newable(Compiler)) {\n      return new Compiler(node, file).compile();\n    }\n\n    return Compiler(node, file); // eslint-disable-line new-cap\n  }\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile. */\n\n\n  function process(doc, cb) {\n    freeze();\n    assertParser('process', processor.Parser);\n    assertCompiler('process', processor.Compiler);\n\n    if (!cb) {\n      return new Promise(executor);\n    }\n\n    executor(null, cb);\n\n    function executor(resolve, reject) {\n      var file = vfile(doc);\n      pipeline.run(processor, {\n        file: file\n      }, done);\n\n      function done(err) {\n        if (err) {\n          reject(err);\n        } else if (resolve) {\n          resolve(file);\n        } else {\n          cb(null, file);\n        }\n      }\n    }\n  }\n  /* Process the given document (in string or VFile\n   * representation), sync. */\n\n\n  function processSync(doc) {\n    var complete = false;\n    var file;\n    freeze();\n    assertParser('processSync', processor.Parser);\n    assertCompiler('processSync', processor.Compiler);\n    file = vfile(doc);\n    process(file, done);\n    assertDone('processSync', 'process', complete);\n    return file;\n\n    function done(err) {\n      complete = true;\n      bail(err);\n    }\n  }\n}\n/* Check if `func` is a constructor. */\n\n\nfunction newable(value) {\n  return typeof value === 'function' && keys(value.prototype);\n}\n/* Check if `value` is an object with keys. */\n\n\nfunction keys(value) {\n  var key;\n\n  for (key in value) {\n    return true;\n  }\n\n  return false;\n}\n/* Assert a parser is available. */\n\n\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`');\n  }\n}\n/* Assert a compiler is available. */\n\n\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`');\n  }\n}\n/* Assert the processor is not frozen. */\n\n\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(['Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ', 'processor first, by invoking it: use `processor()` instead of ', '`processor`.'].join(''));\n  }\n}\n/* Assert `node` is a Unist node. */\n\n\nfunction assertNode(node) {\n  if (!node || !string(node.type)) {\n    throw new Error('Expected node, got `' + node + '`');\n  }\n}\n/* Assert that `complete` is `true`. */\n\n\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');\n  }\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/unified/index.js"],"names":["extend","require","bail","vfile","trough","string","plain","module","exports","unified","freeze","slice","own","hasOwnProperty","pipeline","use","pipelineParse","pipelineRun","pipelineStringify","p","ctx","tree","parse","file","next","run","done","err","contents","stringify","attachers","transformers","namespace","frozen","freezeIndex","processor","data","runSync","process","processSync","destination","length","index","apply","values","plugin","options","transformer","undefined","Infinity","key","value","arguments","assertUnfrozen","call","settings","addPlugin","addList","addPreset","Error","result","plugins","add","entry","find","push","doc","Parser","assertParser","newable","String","node","cb","assertNode","Promise","executor","resolve","reject","complete","assertDone","Compiler","assertCompiler","compile","keys","prototype","name","join","type","asyncName"],"mappings":"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","sourcesContent":["'use strict'\n\n/* Dependencies. */\nvar extend = require('extend')\nvar bail = require('bail')\nvar vfile = require('vfile')\nvar trough = require('trough')\nvar string = require('x-is-string')\nvar plain = require('is-plain-obj')\n\n/* Expose a frozen processor. */\nmodule.exports = unified().freeze()\n\nvar slice = [].slice\nvar own = {}.hasOwnProperty\n\n/* Process pipeline. */\nvar pipeline = trough()\n  .use(pipelineParse)\n  .use(pipelineRun)\n  .use(pipelineStringify)\n\nfunction pipelineParse(p, ctx) {\n  ctx.tree = p.parse(ctx.file)\n}\n\nfunction pipelineRun(p, ctx, next) {\n  p.run(ctx.tree, ctx.file, done)\n\n  function done(err, tree, file) {\n    if (err) {\n      next(err)\n    } else {\n      ctx.tree = tree\n      ctx.file = file\n      next()\n    }\n  }\n}\n\nfunction pipelineStringify(p, ctx) {\n  ctx.file.contents = p.stringify(ctx.tree, ctx.file)\n}\n\n/* Function to create the first processor. */\nfunction unified() {\n  var attachers = []\n  var transformers = trough()\n  var namespace = {}\n  var frozen = false\n  var freezeIndex = -1\n\n  /* Data management. */\n  processor.data = data\n\n  /* Lock. */\n  processor.freeze = freeze\n\n  /* Plug-ins. */\n  processor.attachers = attachers\n  processor.use = use\n\n  /* API. */\n  processor.parse = parse\n  processor.stringify = stringify\n  processor.run = run\n  processor.runSync = runSync\n  processor.process = process\n  processor.processSync = processSync\n\n  /* Expose. */\n  return processor\n\n  /* Create a new processor based on the processor\n   * in the current scope. */\n  function processor() {\n    var destination = unified()\n    var length = attachers.length\n    var index = -1\n\n    while (++index < length) {\n      destination.use.apply(null, attachers[index])\n    }\n\n    destination.data(extend(true, {}, namespace))\n\n    return destination\n  }\n\n  /* Freeze: used to signal a processor that has finished\n   * configuration.\n   *\n   * For example, take unified itself.  It’s frozen.\n   * Plug-ins should not be added to it.  Rather, it should\n   * be extended, by invoking it, before modifying it.\n   *\n   * In essence, always invoke this when exporting a\n   * processor. */\n  function freeze() {\n    var values\n    var plugin\n    var options\n    var transformer\n\n    if (frozen) {\n      return processor\n    }\n\n    while (++freezeIndex < attachers.length) {\n      values = attachers[freezeIndex]\n      plugin = values[0]\n      options = values[1]\n      transformer = null\n\n      if (options === false) {\n        continue\n      }\n\n      if (options === true) {\n        values[1] = undefined\n      }\n\n      transformer = plugin.apply(processor, values.slice(1))\n\n      if (typeof transformer === 'function') {\n        transformers.use(transformer)\n      }\n    }\n\n    frozen = true\n    freezeIndex = Infinity\n\n    return processor\n  }\n\n  /* Data management.\n   * Getter / setter for processor-specific informtion. */\n  function data(key, value) {\n    if (string(key)) {\n      /* Set `key`. */\n      if (arguments.length === 2) {\n        assertUnfrozen('data', frozen)\n\n        namespace[key] = value\n\n        return processor\n      }\n\n      /* Get `key`. */\n      return (own.call(namespace, key) && namespace[key]) || null\n    }\n\n    /* Set space. */\n    if (key) {\n      assertUnfrozen('data', frozen)\n      namespace = key\n      return processor\n    }\n\n    /* Get space. */\n    return namespace\n  }\n\n  /* Plug-in management.\n   *\n   * Pass it:\n   * *   an attacher and options,\n   * *   a preset,\n   * *   a list of presets, attachers, and arguments (list\n   *     of attachers and options). */\n  function use(value) {\n    var settings\n\n    assertUnfrozen('use', frozen)\n\n    if (value === null || value === undefined) {\n      /* Empty */\n    } else if (typeof value === 'function') {\n      addPlugin.apply(null, arguments)\n    } else if (typeof value === 'object') {\n      if ('length' in value) {\n        addList(value)\n      } else {\n        addPreset(value)\n      }\n    } else {\n      throw new Error('Expected usable value, not `' + value + '`')\n    }\n\n    if (settings) {\n      namespace.settings = extend(namespace.settings || {}, settings)\n    }\n\n    return processor\n\n    function addPreset(result) {\n      addList(result.plugins)\n\n      if (result.settings) {\n        settings = extend(settings || {}, result.settings)\n      }\n    }\n\n    function add(value) {\n      if (typeof value === 'function') {\n        addPlugin(value)\n      } else if (typeof value === 'object') {\n        if ('length' in value) {\n          addPlugin.apply(null, value)\n        } else {\n          addPreset(value)\n        }\n      } else {\n        throw new Error('Expected usable value, not `' + value + '`')\n      }\n    }\n\n    function addList(plugins) {\n      var length\n      var index\n\n      if (plugins === null || plugins === undefined) {\n        /* Empty */\n      } else if (typeof plugins === 'object' && 'length' in plugins) {\n        length = plugins.length\n        index = -1\n\n        while (++index < length) {\n          add(plugins[index])\n        }\n      } else {\n        throw new Error('Expected a list of plugins, not `' + plugins + '`')\n      }\n    }\n\n    function addPlugin(plugin, value) {\n      var entry = find(plugin)\n\n      if (entry) {\n        if (plain(entry[1]) && plain(value)) {\n          value = extend(entry[1], value)\n        }\n\n        entry[1] = value\n      } else {\n        attachers.push(slice.call(arguments))\n      }\n    }\n  }\n\n  function find(plugin) {\n    var length = attachers.length\n    var index = -1\n    var entry\n\n    while (++index < length) {\n      entry = attachers[index]\n\n      if (entry[0] === plugin) {\n        return entry\n      }\n    }\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the\n   * processor. */\n  function parse(doc) {\n    var file = vfile(doc)\n    var Parser\n\n    freeze()\n    Parser = processor.Parser\n    assertParser('parse', Parser)\n\n    if (newable(Parser)) {\n      return new Parser(String(file), file).parse()\n    }\n\n    return Parser(String(file), file) // eslint-disable-line new-cap\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), async. */\n  function run(node, file, cb) {\n    assertNode(node)\n    freeze()\n\n    if (!cb && typeof file === 'function') {\n      cb = file\n      file = null\n    }\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      transformers.run(node, vfile(file), done)\n\n      function done(err, tree, file) {\n        tree = tree || node\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(tree)\n        } else {\n          cb(null, tree, file)\n        }\n      }\n    }\n  }\n\n  /* Run transforms on a Unist node representation of a file\n   * (in string or VFile representation), sync. */\n  function runSync(node, file) {\n    var complete = false\n    var result\n\n    run(node, file, done)\n\n    assertDone('runSync', 'run', complete)\n\n    return result\n\n    function done(err, tree) {\n      complete = true\n      bail(err)\n      result = tree\n    }\n  }\n\n  /* Stringify a Unist node representation of a file\n   * (in string or VFile representation) into a string\n   * using the `Compiler` on the processor. */\n  function stringify(node, doc) {\n    var file = vfile(doc)\n    var Compiler\n\n    freeze()\n    Compiler = processor.Compiler\n    assertCompiler('stringify', Compiler)\n    assertNode(node)\n\n    if (newable(Compiler)) {\n      return new Compiler(node, file).compile()\n    }\n\n    return Compiler(node, file) // eslint-disable-line new-cap\n  }\n\n  /* Parse a file (in string or VFile representation)\n   * into a Unist node using the `Parser` on the processor,\n   * then run transforms on that node, and compile the\n   * resulting node using the `Compiler` on the processor,\n   * and store that result on the VFile. */\n  function process(doc, cb) {\n    freeze()\n    assertParser('process', processor.Parser)\n    assertCompiler('process', processor.Compiler)\n\n    if (!cb) {\n      return new Promise(executor)\n    }\n\n    executor(null, cb)\n\n    function executor(resolve, reject) {\n      var file = vfile(doc)\n\n      pipeline.run(processor, {file: file}, done)\n\n      function done(err) {\n        if (err) {\n          reject(err)\n        } else if (resolve) {\n          resolve(file)\n        } else {\n          cb(null, file)\n        }\n      }\n    }\n  }\n\n  /* Process the given document (in string or VFile\n   * representation), sync. */\n  function processSync(doc) {\n    var complete = false\n    var file\n\n    freeze()\n    assertParser('processSync', processor.Parser)\n    assertCompiler('processSync', processor.Compiler)\n    file = vfile(doc)\n\n    process(file, done)\n\n    assertDone('processSync', 'process', complete)\n\n    return file\n\n    function done(err) {\n      complete = true\n      bail(err)\n    }\n  }\n}\n\n/* Check if `func` is a constructor. */\nfunction newable(value) {\n  return typeof value === 'function' && keys(value.prototype)\n}\n\n/* Check if `value` is an object with keys. */\nfunction keys(value) {\n  var key\n  for (key in value) {\n    return true\n  }\n  return false\n}\n\n/* Assert a parser is available. */\nfunction assertParser(name, Parser) {\n  if (typeof Parser !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Parser`')\n  }\n}\n\n/* Assert a compiler is available. */\nfunction assertCompiler(name, Compiler) {\n  if (typeof Compiler !== 'function') {\n    throw new Error('Cannot `' + name + '` without `Compiler`')\n  }\n}\n\n/* Assert the processor is not frozen. */\nfunction assertUnfrozen(name, frozen) {\n  if (frozen) {\n    throw new Error(\n      [\n        'Cannot invoke `' + name + '` on a frozen processor.\\nCreate a new ',\n        'processor first, by invoking it: use `processor()` instead of ',\n        '`processor`.'\n      ].join('')\n    )\n  }\n}\n\n/* Assert `node` is a Unist node. */\nfunction assertNode(node) {\n  if (!node || !string(node.type)) {\n    throw new Error('Expected node, got `' + node + '`')\n  }\n}\n\n/* Assert that `complete` is `true`. */\nfunction assertDone(name, asyncName, complete) {\n  if (!complete) {\n    throw new Error(\n      '`' + name + '` finished async. Use `' + asyncName + '` instead'\n    )\n  }\n}\n"]},"metadata":{},"sourceType":"script"}