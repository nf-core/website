{"ast":null,"code":"'use strict';\n\nvar openCloseTag = require('../util/html').openCloseTag;\n\nmodule.exports = blockHTML;\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_LT = '<';\n\nfunction blockHTML(eat, value, silent) {\n  var self = this;\n  var blocks = self.options.blocks;\n  var length = value.length;\n  var index = 0;\n  var next;\n  var line;\n  var offset;\n  var character;\n  var count;\n  var sequence;\n  var subvalue;\n  var sequences = [[/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true], [/^<!--/, /-->/, true], [/^<\\?/, /\\?>/, true], [/^<![A-Za-z]/, />/, true], [/^<!\\[CDATA\\[/, /\\]\\]>/, true], [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(openCloseTag.source + '\\\\s*$'), /^$/, false]];\n  /* Eat initial spacing. */\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_LT) {\n    return;\n  }\n\n  next = value.indexOf(C_NEWLINE, index + 1);\n  next = next === -1 ? length : next;\n  line = value.slice(index, next);\n  offset = -1;\n  count = sequences.length;\n\n  while (++offset < count) {\n    if (sequences[offset][0].test(line)) {\n      sequence = sequences[offset];\n      break;\n    }\n  }\n\n  if (!sequence) {\n    return;\n  }\n\n  if (silent) {\n    return sequence[2];\n  }\n\n  index = next;\n\n  if (!sequence[1].test(line)) {\n    while (index < length) {\n      next = value.indexOf(C_NEWLINE, index + 1);\n      next = next === -1 ? length : next;\n      line = value.slice(index + 1, next);\n\n      if (sequence[1].test(line)) {\n        if (line) {\n          index = next;\n        }\n\n        break;\n      }\n\n      index = next;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n  return eat(subvalue)({\n    type: 'html',\n    value: subvalue\n  });\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/tokenize/html-block.js"],"names":["openCloseTag","require","module","exports","blockHTML","C_TAB","C_SPACE","C_NEWLINE","C_LT","eat","value","silent","self","blocks","options","length","index","next","line","offset","character","count","sequence","subvalue","sequences","RegExp","join","source","charAt","indexOf","slice","test","type"],"mappings":"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","sourcesContent":["'use strict';\n\nvar openCloseTag = require('../util/html').openCloseTag;\n\nmodule.exports = blockHTML;\n\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_LT = '<';\n\nfunction blockHTML(eat, value, silent) {\n  var self = this;\n  var blocks = self.options.blocks;\n  var length = value.length;\n  var index = 0;\n  var next;\n  var line;\n  var offset;\n  var character;\n  var count;\n  var sequence;\n  var subvalue;\n\n  var sequences = [\n    [/^<(script|pre|style)(?=(\\s|>|$))/i, /<\\/(script|pre|style)>/i, true],\n    [/^<!--/, /-->/, true],\n    [/^<\\?/, /\\?>/, true],\n    [/^<![A-Za-z]/, />/, true],\n    [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n    [new RegExp('^</?(' + blocks.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n    [new RegExp(openCloseTag.source + '\\\\s*$'), /^$/, false]\n  ];\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_TAB && character !== C_SPACE) {\n      break;\n    }\n\n    index++;\n  }\n\n  if (value.charAt(index) !== C_LT) {\n    return;\n  }\n\n  next = value.indexOf(C_NEWLINE, index + 1);\n  next = next === -1 ? length : next;\n  line = value.slice(index, next);\n  offset = -1;\n  count = sequences.length;\n\n  while (++offset < count) {\n    if (sequences[offset][0].test(line)) {\n      sequence = sequences[offset];\n      break;\n    }\n  }\n\n  if (!sequence) {\n    return;\n  }\n\n  if (silent) {\n    return sequence[2];\n  }\n\n  index = next;\n\n  if (!sequence[1].test(line)) {\n    while (index < length) {\n      next = value.indexOf(C_NEWLINE, index + 1);\n      next = next === -1 ? length : next;\n      line = value.slice(index + 1, next);\n\n      if (sequence[1].test(line)) {\n        if (line) {\n          index = next;\n        }\n\n        break;\n      }\n\n      index = next;\n    }\n  }\n\n  subvalue = value.slice(0, index);\n\n  return eat(subvalue)({type: 'html', value: subvalue});\n}\n"]},"metadata":{},"sourceType":"script"}