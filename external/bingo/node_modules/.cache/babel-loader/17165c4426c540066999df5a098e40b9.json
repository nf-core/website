{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\nvar own = {}.hasOwnProperty;\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n/* Map of characters, which can be used to mark link\n * and image titles. */\n\nvar LINK_MARKERS = {};\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\n\nvar COMMONMARK_LINK_MARKERS = {};\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var pedantic = self.options.pedantic;\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n  /* Detect whether this is an image. */\n\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n  /* Eat the opening. */\n\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n  /* Exit when this is a link and we’re already inside\n   * a link. */\n\n\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n  /* Eat the content. */\n\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n      /* In GFM mode, brackets in code still count.\n       * In all other modes, they don’t.  This empty\n       * block prevents the next statements are\n       * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (!pedantic) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n  /* Eat the content closing. */\n\n\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n  /* Eat white-space. */\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat the URL. */\n\n\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && own.call(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (!pedantic) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n  /* Eat white-space. */\n\n\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n  /* Eat the title. */\n\n  if (queue && own.call(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {\n    nonTerminated: false\n  });\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/remark-parse/lib/tokenize/link.js"],"names":["whitespace","require","locate","module","exports","link","locator","own","hasOwnProperty","C_BACKSLASH","C_BRACKET_OPEN","C_BRACKET_CLOSE","C_PAREN_OPEN","C_PAREN_CLOSE","C_LT","C_GT","C_TICK","C_DOUBLE_QUOTE","C_SINGLE_QUOTE","LINK_MARKERS","COMMONMARK_LINK_MARKERS","eat","value","silent","self","subvalue","index","character","charAt","pedantic","options","commonmark","gfm","closed","count","opening","beforeURL","beforeTitle","subqueue","hasMarker","markers","isImage","content","marker","length","title","depth","queue","url","now","exit","node","inLink","column","offset","call","decode","raw","unescape","test","end","nonTerminated","type","alt","enterLink","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\n\nmodule.exports = link;\nlink.locator = locate;\n\nvar own = {}.hasOwnProperty;\n\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\nvar C_PAREN_OPEN = '(';\nvar C_PAREN_CLOSE = ')';\nvar C_LT = '<';\nvar C_GT = '>';\nvar C_TICK = '`';\nvar C_DOUBLE_QUOTE = '\"';\nvar C_SINGLE_QUOTE = '\\'';\n\n/* Map of characters, which can be used to mark link\n * and image titles. */\nvar LINK_MARKERS = {};\n\nLINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nLINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\n\n/* Map of characters, which can be used to mark link\n * and image titles in commonmark-mode. */\nvar COMMONMARK_LINK_MARKERS = {};\n\nCOMMONMARK_LINK_MARKERS[C_DOUBLE_QUOTE] = C_DOUBLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_SINGLE_QUOTE] = C_SINGLE_QUOTE;\nCOMMONMARK_LINK_MARKERS[C_PAREN_OPEN] = C_PAREN_CLOSE;\n\nfunction link(eat, value, silent) {\n  var self = this;\n  var subvalue = '';\n  var index = 0;\n  var character = value.charAt(0);\n  var pedantic = self.options.pedantic;\n  var commonmark = self.options.commonmark;\n  var gfm = self.options.gfm;\n  var closed;\n  var count;\n  var opening;\n  var beforeURL;\n  var beforeTitle;\n  var subqueue;\n  var hasMarker;\n  var markers;\n  var isImage;\n  var content;\n  var marker;\n  var length;\n  var title;\n  var depth;\n  var queue;\n  var url;\n  var now;\n  var exit;\n  var node;\n\n  /* Detect whether this is an image. */\n  if (character === '!') {\n    isImage = true;\n    subvalue = character;\n    character = value.charAt(++index);\n  }\n\n  /* Eat the opening. */\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  /* Exit when this is a link and we’re already inside\n   * a link. */\n  if (!isImage && self.inLink) {\n    return;\n  }\n\n  subvalue += character;\n  queue = '';\n  index++;\n\n  /* Eat the content. */\n  length = value.length;\n  now = eat.now();\n  depth = 0;\n\n  now.column += index;\n  now.offset += index;\n\n  while (index < length) {\n    character = value.charAt(index);\n    subqueue = character;\n\n    if (character === C_TICK) {\n      /* Inline-code in link content. */\n      count = 1;\n\n      while (value.charAt(index + 1) === C_TICK) {\n        subqueue += character;\n        index++;\n        count++;\n      }\n\n      if (!opening) {\n        opening = count;\n      } else if (count >= opening) {\n        opening = 0;\n      }\n    } else if (character === C_BACKSLASH) {\n      /* Allow brackets to be escaped. */\n      index++;\n      subqueue += value.charAt(index);\n    /* In GFM mode, brackets in code still count.\n     * In all other modes, they don’t.  This empty\n     * block prevents the next statements are\n     * entered. */\n    } else if ((!opening || gfm) && character === C_BRACKET_OPEN) {\n      depth++;\n    } else if ((!opening || gfm) && character === C_BRACKET_CLOSE) {\n      if (depth) {\n        depth--;\n      } else {\n        /* Allow white-space between content and\n         * url in GFM mode. */\n        if (!pedantic) {\n          while (index < length) {\n            character = value.charAt(index + 1);\n\n            if (!whitespace(character)) {\n              break;\n            }\n\n            subqueue += character;\n            index++;\n          }\n        }\n\n        if (value.charAt(index + 1) !== C_PAREN_OPEN) {\n          return;\n        }\n\n        subqueue += C_PAREN_OPEN;\n        closed = true;\n        index++;\n\n        break;\n      }\n    }\n\n    queue += subqueue;\n    subqueue = '';\n    index++;\n  }\n\n  /* Eat the content closing. */\n  if (!closed) {\n    return;\n  }\n\n  content = queue;\n  subvalue += queue + subqueue;\n  index++;\n\n  /* Eat white-space. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat the URL. */\n  character = value.charAt(index);\n  markers = commonmark ? COMMONMARK_LINK_MARKERS : LINK_MARKERS;\n  queue = '';\n  beforeURL = subvalue;\n\n  if (character === C_LT) {\n    index++;\n    beforeURL += C_LT;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_GT) {\n        break;\n      }\n\n      if (commonmark && character === '\\n') {\n        return;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    if (value.charAt(index) !== C_GT) {\n      return;\n    }\n\n    subvalue += C_LT + queue + C_GT;\n    url = queue;\n    index++;\n  } else {\n    character = null;\n    subqueue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (subqueue && own.call(markers, character)) {\n        break;\n      }\n\n      if (whitespace(character)) {\n        if (!pedantic) {\n          break;\n        }\n\n        subqueue += character;\n      } else {\n        if (character === C_PAREN_OPEN) {\n          depth++;\n        } else if (character === C_PAREN_CLOSE) {\n          if (depth === 0) {\n            break;\n          }\n\n          depth--;\n        }\n\n        queue += subqueue;\n        subqueue = '';\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        queue += character;\n      }\n\n      index++;\n    }\n\n    subvalue += queue;\n    url = queue;\n    index = subvalue.length;\n  }\n\n  /* Eat white-space. */\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  subvalue += queue;\n\n  /* Eat the title. */\n  if (queue && own.call(markers, character)) {\n    index++;\n    subvalue += character;\n    queue = '';\n    marker = markers[character];\n    beforeTitle = subvalue;\n\n    /* In commonmark-mode, things are pretty easy: the\n     * marker cannot occur inside the title.\n     *\n     * Non-commonmark does, however, support nested\n     * delimiters. */\n    if (commonmark) {\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          break;\n        }\n\n        if (character === C_BACKSLASH) {\n          queue += C_BACKSLASH;\n          character = value.charAt(++index);\n        }\n\n        index++;\n        queue += character;\n      }\n\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        return;\n      }\n\n      title = queue;\n      subvalue += queue + character;\n      index++;\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (!whitespace(character)) {\n          break;\n        }\n\n        subvalue += character;\n        index++;\n      }\n    } else {\n      subqueue = '';\n\n      while (index < length) {\n        character = value.charAt(index);\n\n        if (character === marker) {\n          if (hasMarker) {\n            queue += marker + subqueue;\n            subqueue = '';\n          }\n\n          hasMarker = true;\n        } else if (!hasMarker) {\n          queue += character;\n        } else if (character === C_PAREN_CLOSE) {\n          subvalue += queue + marker + subqueue;\n          title = queue;\n          break;\n        } else if (whitespace(character)) {\n          subqueue += character;\n        } else {\n          queue += marker + subqueue + character;\n          subqueue = '';\n          hasMarker = false;\n        }\n\n        index++;\n      }\n    }\n  }\n\n  if (value.charAt(index) !== C_PAREN_CLOSE) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  subvalue += C_PAREN_CLOSE;\n\n  url = self.decode.raw(self.unescape(url), eat(beforeURL).test().end, {nonTerminated: false});\n\n  if (title) {\n    beforeTitle = eat(beforeTitle).test().end;\n    title = self.decode.raw(self.unescape(title), beforeTitle);\n  }\n\n  node = {\n    type: isImage ? 'image' : 'link',\n    title: title || null,\n    url: url\n  };\n\n  if (isImage) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  } else {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  }\n\n  return eat(subvalue)(node);\n}\n"]},"metadata":{},"sourceType":"script"}