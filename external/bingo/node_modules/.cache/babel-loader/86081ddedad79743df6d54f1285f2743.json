{"ast":null,"code":"'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n  /* Eat initial spacing. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n  /* Eat the fence. */\n\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n  /* Eat spacing before flag. */\n\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n  /* Eat flag. */\n\n\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE || character === C_TILDE || character === C_TICK) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n  /* Eat content. */\n\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n\n\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/remark-parse/lib/tokenize/code-fenced.js"],"names":["trim","require","module","exports","fencedCode","C_NEWLINE","C_TAB","C_SPACE","C_TILDE","C_TICK","MIN_FENCE_COUNT","CODE_INDENT_COUNT","eat","value","silent","self","settings","options","length","index","subvalue","fenceCount","marker","character","flag","queue","content","exdentedContent","closing","exdentedClosing","indent","now","gfm","charAt","column","offset","decode","raw","unescape","slice","type","lang"],"mappings":"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","sourcesContent":["'use strict';\n\nvar trim = require('trim-trailing-lines');\n\nmodule.exports = fencedCode;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_TILDE = '~';\nvar C_TICK = '`';\n\nvar MIN_FENCE_COUNT = 3;\nvar CODE_INDENT_COUNT = 4;\n\nfunction fencedCode(eat, value, silent) {\n  var self = this;\n  var settings = self.options;\n  var length = value.length + 1;\n  var index = 0;\n  var subvalue = '';\n  var fenceCount;\n  var marker;\n  var character;\n  var flag;\n  var queue;\n  var content;\n  var exdentedContent;\n  var closing;\n  var exdentedClosing;\n  var indent;\n  var now;\n\n  if (!settings.gfm) {\n    return;\n  }\n\n  /* Eat initial spacing. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  indent = index;\n\n  /* Eat the fence. */\n  character = value.charAt(index);\n\n  if (character !== C_TILDE && character !== C_TICK) {\n    return;\n  }\n\n  index++;\n  marker = character;\n  fenceCount = 1;\n  subvalue += character;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      break;\n    }\n\n    subvalue += character;\n    fenceCount++;\n    index++;\n  }\n\n  if (fenceCount < MIN_FENCE_COUNT) {\n    return;\n  }\n\n  /* Eat spacing before flag. */\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE && character !== C_TAB) {\n      break;\n    }\n\n    subvalue += character;\n    index++;\n  }\n\n  /* Eat flag. */\n  flag = '';\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (\n      character === C_NEWLINE ||\n      character === C_TILDE ||\n      character === C_TICK\n    ) {\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      flag += queue + character;\n      queue = '';\n    }\n\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  if (character && character !== C_NEWLINE) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  now = eat.now();\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n\n  subvalue += flag;\n  flag = self.decode.raw(self.unescape(flag), now);\n\n  if (queue) {\n    subvalue += queue;\n  }\n\n  queue = '';\n  closing = '';\n  exdentedClosing = '';\n  content = '';\n  exdentedContent = '';\n\n  /* Eat content. */\n  while (index < length) {\n    character = value.charAt(index);\n    content += closing;\n    exdentedContent += exdentedClosing;\n    closing = '';\n    exdentedClosing = '';\n\n    if (character !== C_NEWLINE) {\n      content += character;\n      exdentedClosing += character;\n      index++;\n      continue;\n    }\n\n    /* Add the newline to `subvalue` if its the first\n     * character.  Otherwise, add it to the `closing`\n     * queue. */\n    if (content) {\n      closing += character;\n      exdentedClosing += character;\n    } else {\n      subvalue += character;\n    }\n\n    queue = '';\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue.slice(indent);\n\n    if (queue.length >= CODE_INDENT_COUNT) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== marker) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    closing += queue;\n    exdentedClosing += queue;\n\n    if (queue.length < fenceCount) {\n      continue;\n    }\n\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character !== C_SPACE && character !== C_TAB) {\n        break;\n      }\n\n      closing += character;\n      exdentedClosing += character;\n      index++;\n    }\n\n    if (!character || character === C_NEWLINE) {\n      break;\n    }\n  }\n\n  subvalue += content + closing;\n\n  return eat(subvalue)({\n    type: 'code',\n    lang: flag || null,\n    value: trim(exdentedContent)\n  });\n}\n"]},"metadata":{},"sourceType":"script"}