{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nvar locate = require('../locate/link');\n\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n  /* Check whether we’re eating an image. */\n\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = '';\n  /* Check whether we’re eating a footnote. */\n\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and we’ll enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n  /* Eat the text. */\n\n\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n  /* Inline footnotes cannot have an identifier. */\n\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  }\n  /* Brackets cannot be inside the identifier. */\n\n\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/tokenize/reference.js"],"names":["whitespace","require","locate","normalize","module","exports","reference","locator","T_LINK","T_IMAGE","T_FOOTNOTE","REFERENCE_TYPE_SHORTCUT","REFERENCE_TYPE_COLLAPSED","REFERENCE_TYPE_FULL","C_CARET","C_BACKSLASH","C_BRACKET_OPEN","C_BRACKET_CLOSE","eat","value","silent","self","character","charAt","index","length","subvalue","intro","type","referenceType","content","identifier","now","node","exit","queue","bracketed","depth","options","footnotes","inLink","indexOf","children","tokenizeInline","column","offset","enterLink","alt","decode","raw","unescape"],"mappings":"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","sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\nvar locate = require('../locate/link');\nvar normalize = require('../util/normalize');\n\nmodule.exports = reference;\nreference.locator = locate;\n\nvar T_LINK = 'link';\nvar T_IMAGE = 'image';\nvar T_FOOTNOTE = 'footnote';\nvar REFERENCE_TYPE_SHORTCUT = 'shortcut';\nvar REFERENCE_TYPE_COLLAPSED = 'collapsed';\nvar REFERENCE_TYPE_FULL = 'full';\nvar C_CARET = '^';\nvar C_BACKSLASH = '\\\\';\nvar C_BRACKET_OPEN = '[';\nvar C_BRACKET_CLOSE = ']';\n\nfunction reference(eat, value, silent) {\n  var self = this;\n  var character = value.charAt(0);\n  var index = 0;\n  var length = value.length;\n  var subvalue = '';\n  var intro = '';\n  var type = T_LINK;\n  var referenceType = REFERENCE_TYPE_SHORTCUT;\n  var content;\n  var identifier;\n  var now;\n  var node;\n  var exit;\n  var queue;\n  var bracketed;\n  var depth;\n\n  /* Check whether we’re eating an image. */\n  if (character === '!') {\n    type = T_IMAGE;\n    intro = character;\n    character = value.charAt(++index);\n  }\n\n  if (character !== C_BRACKET_OPEN) {\n    return;\n  }\n\n  index++;\n  intro += character;\n  queue = '';\n\n  /* Check whether we’re eating a footnote. */\n  if (self.options.footnotes && value.charAt(index) === C_CARET) {\n    /* Exit if `![^` is found, so the `!` will be seen as text after this,\n     * and we’ll enter this function again when `[^` is found. */\n    if (type === T_IMAGE) {\n      return;\n    }\n\n    intro += C_CARET;\n    index++;\n    type = T_FOOTNOTE;\n  }\n\n  /* Eat the text. */\n  depth = 0;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_OPEN) {\n      bracketed = true;\n      depth++;\n    } else if (character === C_BRACKET_CLOSE) {\n      if (!depth) {\n        break;\n      }\n\n      depth--;\n    }\n\n    if (character === C_BACKSLASH) {\n      queue += C_BACKSLASH;\n      character = value.charAt(++index);\n    }\n\n    queue += character;\n    index++;\n  }\n\n  subvalue = queue;\n  content = queue;\n  character = value.charAt(index);\n\n  if (character !== C_BRACKET_CLOSE) {\n    return;\n  }\n\n  index++;\n  subvalue += character;\n  queue = '';\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (!whitespace(character)) {\n      break;\n    }\n\n    queue += character;\n    index++;\n  }\n\n  character = value.charAt(index);\n\n  /* Inline footnotes cannot have an identifier. */\n  if (type !== T_FOOTNOTE && character === C_BRACKET_OPEN) {\n    identifier = '';\n    queue += character;\n    index++;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_BRACKET_OPEN || character === C_BRACKET_CLOSE) {\n        break;\n      }\n\n      if (character === C_BACKSLASH) {\n        identifier += C_BACKSLASH;\n        character = value.charAt(++index);\n      }\n\n      identifier += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (character === C_BRACKET_CLOSE) {\n      referenceType = identifier ? REFERENCE_TYPE_FULL : REFERENCE_TYPE_COLLAPSED;\n      queue += identifier + character;\n      index++;\n    } else {\n      identifier = '';\n    }\n\n    subvalue += queue;\n    queue = '';\n  } else {\n    if (!content) {\n      return;\n    }\n\n    identifier = content;\n  }\n\n  /* Brackets cannot be inside the identifier. */\n  if (referenceType !== REFERENCE_TYPE_FULL && bracketed) {\n    return;\n  }\n\n  subvalue = intro + subvalue;\n\n  if (type === T_LINK && self.inLink) {\n    return null;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  if (type === T_FOOTNOTE && content.indexOf(' ') !== -1) {\n    return eat(subvalue)({\n      type: 'footnote',\n      children: this.tokenizeInline(content, eat.now())\n    });\n  }\n\n  now = eat.now();\n  now.column += intro.length;\n  now.offset += intro.length;\n  identifier = referenceType === REFERENCE_TYPE_FULL ? identifier : content;\n\n  node = {\n    type: type + 'Reference',\n    identifier: normalize(identifier)\n  };\n\n  if (type === T_LINK || type === T_IMAGE) {\n    node.referenceType = referenceType;\n  }\n\n  if (type === T_LINK) {\n    exit = self.enterLink();\n    node.children = self.tokenizeInline(content, now);\n    exit();\n  } else if (type === T_IMAGE) {\n    node.alt = self.decode.raw(self.unescape(content), now) || null;\n  }\n\n  return eat(subvalue)(node);\n}\n"]},"metadata":{},"sourceType":"script"}