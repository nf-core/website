{"ast":null,"code":"'use strict';\n\nmodule.exports = setextHeading;\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_EQUALS = '=';\nvar C_DASH = '-';\nvar MAX_HEADING_INDENT = 3;\n/* Map of characters which can be used to mark setext\n * headers, mapping to their corresponding depth. */\n\nvar SETEXT_MARKERS = {};\nSETEXT_MARKERS[C_EQUALS] = 1;\nSETEXT_MARKERS[C_DASH] = 2;\n\nfunction setextHeading(eat, value, silent) {\n  var self = this;\n  var now = eat.now();\n  var length = value.length;\n  var index = -1;\n  var subvalue = '';\n  var content;\n  var queue;\n  var character;\n  var marker;\n  var depth;\n  /* Eat initial indentation. */\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n  /* Eat content. */\n\n\n  content = '';\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      index--;\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      content += queue + character;\n      queue = '';\n    }\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n  /* Ensure the content is followed by a newline and a\n   * valid marker. */\n\n  character = value.charAt(++index);\n  marker = value.charAt(++index);\n\n  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {\n    return;\n  }\n\n  subvalue += character;\n  /* Eat Setext-line. */\n\n  queue = marker;\n  depth = SETEXT_MARKERS[marker];\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      if (character !== C_NEWLINE) {\n        return;\n      }\n\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/tokenize/heading-setext.js"],"names":["module","exports","setextHeading","C_NEWLINE","C_TAB","C_SPACE","C_EQUALS","C_DASH","MAX_HEADING_INDENT","SETEXT_MARKERS","eat","value","silent","self","now","length","index","subvalue","content","queue","character","marker","depth","charAt","column","offset","type","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = setextHeading;\n\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_SPACE = ' ';\nvar C_EQUALS = '=';\nvar C_DASH = '-';\n\nvar MAX_HEADING_INDENT = 3;\n\n/* Map of characters which can be used to mark setext\n * headers, mapping to their corresponding depth. */\nvar SETEXT_MARKERS = {};\n\nSETEXT_MARKERS[C_EQUALS] = 1;\nSETEXT_MARKERS[C_DASH] = 2;\n\nfunction setextHeading(eat, value, silent) {\n  var self = this;\n  var now = eat.now();\n  var length = value.length;\n  var index = -1;\n  var subvalue = '';\n  var content;\n  var queue;\n  var character;\n  var marker;\n  var depth;\n\n  /* Eat initial indentation. */\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== C_SPACE || index >= MAX_HEADING_INDENT) {\n      index--;\n      break;\n    }\n\n    subvalue += character;\n  }\n\n  /* Eat content. */\n  content = '';\n  queue = '';\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character === C_NEWLINE) {\n      index--;\n      break;\n    }\n\n    if (character === C_SPACE || character === C_TAB) {\n      queue += character;\n    } else {\n      content += queue + character;\n      queue = '';\n    }\n  }\n\n  now.column += subvalue.length;\n  now.offset += subvalue.length;\n  subvalue += content + queue;\n\n  /* Ensure the content is followed by a newline and a\n   * valid marker. */\n  character = value.charAt(++index);\n  marker = value.charAt(++index);\n\n  if (character !== C_NEWLINE || !SETEXT_MARKERS[marker]) {\n    return;\n  }\n\n  subvalue += character;\n\n  /* Eat Setext-line. */\n  queue = marker;\n  depth = SETEXT_MARKERS[marker];\n\n  while (++index < length) {\n    character = value.charAt(index);\n\n    if (character !== marker) {\n      if (character !== C_NEWLINE) {\n        return;\n      }\n\n      index--;\n      break;\n    }\n\n    queue += character;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  return eat(subvalue + queue)({\n    type: 'heading',\n    depth: depth,\n    children: self.tokenizeInline(content, now)\n  });\n}\n"]},"metadata":{},"sourceType":"script"}