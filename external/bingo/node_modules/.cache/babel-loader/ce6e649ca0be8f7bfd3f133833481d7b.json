{"ast":null,"code":"'use strict';\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar getIndent = require('./get-indentation');\n\nmodule.exports = indentation;\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n/* Remove the minimum indent from every line in `value`.\n * Supports both tab, spaced, and mixed indentation (as\n * well as possible). */\n\nfunction indentation(value, maximum) {\n  var values = value.split(C_NEWLINE);\n  var position = values.length + 1;\n  var minIndent = Infinity;\n  var matrix = [];\n  var index;\n  var indentation;\n  var stops;\n  var padding;\n  values.unshift(repeat(C_SPACE, maximum) + '!');\n\n  while (position--) {\n    indentation = getIndent(values[position]);\n    matrix[position] = indentation.stops;\n\n    if (trim(values[position]).length === 0) {\n      continue;\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent;\n      }\n    } else {\n      minIndent = Infinity;\n      break;\n    }\n  }\n\n  if (minIndent !== Infinity) {\n    position = values.length;\n\n    while (position--) {\n      stops = matrix[position];\n      index = minIndent;\n\n      while (index && !(index in stops)) {\n        index--;\n      }\n\n      if (trim(values[position]).length !== 0 && minIndent && index !== minIndent) {\n        padding = C_TAB;\n      } else {\n        padding = '';\n      }\n\n      values[position] = padding + values[position].slice(index in stops ? stops[index] + 1 : 0);\n    }\n  }\n\n  values.shift();\n  return values.join(C_NEWLINE);\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/util/remove-indentation.js"],"names":["trim","require","repeat","getIndent","module","exports","indentation","C_SPACE","C_NEWLINE","C_TAB","value","maximum","values","split","position","length","minIndent","Infinity","matrix","index","stops","padding","unshift","indent","slice","shift","join"],"mappings":"AAAA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIC,MAAM,GAAGD,OAAO,CAAC,eAAD,CAApB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,mBAAD,CAAvB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,WAAjB;AAEA,IAAIC,OAAO,GAAG,GAAd;AACA,IAAIC,SAAS,GAAG,IAAhB;AACA,IAAIC,KAAK,GAAG,IAAZ;AAEA;;;;AAGA,SAASH,WAAT,CAAqBI,KAArB,EAA4BC,OAA5B,EAAqC;AACnC,MAAIC,MAAM,GAAGF,KAAK,CAACG,KAAN,CAAYL,SAAZ,CAAb;AACA,MAAIM,QAAQ,GAAGF,MAAM,CAACG,MAAP,GAAgB,CAA/B;AACA,MAAIC,SAAS,GAAGC,QAAhB;AACA,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,KAAJ;AACA,MAAIb,WAAJ;AACA,MAAIc,KAAJ;AACA,MAAIC,OAAJ;AAEAT,EAAAA,MAAM,CAACU,OAAP,CAAepB,MAAM,CAACK,OAAD,EAAUI,OAAV,CAAN,GAA2B,GAA1C;;AAEA,SAAOG,QAAQ,EAAf,EAAmB;AACjBR,IAAAA,WAAW,GAAGH,SAAS,CAACS,MAAM,CAACE,QAAD,CAAP,CAAvB;AAEAI,IAAAA,MAAM,CAACJ,QAAD,CAAN,GAAmBR,WAAW,CAACc,KAA/B;;AAEA,QAAIpB,IAAI,CAACY,MAAM,CAACE,QAAD,CAAP,CAAJ,CAAuBC,MAAvB,KAAkC,CAAtC,EAAyC;AACvC;AACD;;AAED,QAAIT,WAAW,CAACiB,MAAhB,EAAwB;AACtB,UAAIjB,WAAW,CAACiB,MAAZ,GAAqB,CAArB,IAA0BjB,WAAW,CAACiB,MAAZ,GAAqBP,SAAnD,EAA8D;AAC5DA,QAAAA,SAAS,GAAGV,WAAW,CAACiB,MAAxB;AACD;AACF,KAJD,MAIO;AACLP,MAAAA,SAAS,GAAGC,QAAZ;AAEA;AACD;AACF;;AAED,MAAID,SAAS,KAAKC,QAAlB,EAA4B;AAC1BH,IAAAA,QAAQ,GAAGF,MAAM,CAACG,MAAlB;;AAEA,WAAOD,QAAQ,EAAf,EAAmB;AACjBM,MAAAA,KAAK,GAAGF,MAAM,CAACJ,QAAD,CAAd;AACAK,MAAAA,KAAK,GAAGH,SAAR;;AAEA,aAAOG,KAAK,IAAI,EAAEA,KAAK,IAAIC,KAAX,CAAhB,EAAmC;AACjCD,QAAAA,KAAK;AACN;;AAED,UACEnB,IAAI,CAACY,MAAM,CAACE,QAAD,CAAP,CAAJ,CAAuBC,MAAvB,KAAkC,CAAlC,IACAC,SADA,IAEAG,KAAK,KAAKH,SAHZ,EAIE;AACAK,QAAAA,OAAO,GAAGZ,KAAV;AACD,OAND,MAMO;AACLY,QAAAA,OAAO,GAAG,EAAV;AACD;;AAEDT,MAAAA,MAAM,CAACE,QAAD,CAAN,GAAmBO,OAAO,GAAGT,MAAM,CAACE,QAAD,CAAN,CAAiBU,KAAjB,CAC3BL,KAAK,IAAIC,KAAT,GAAiBA,KAAK,CAACD,KAAD,CAAL,GAAe,CAAhC,GAAoC,CADT,CAA7B;AAGD;AACF;;AAEDP,EAAAA,MAAM,CAACa,KAAP;AAEA,SAAOb,MAAM,CAACc,IAAP,CAAYlB,SAAZ,CAAP;AACD","sourcesContent":["'use strict';\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar getIndent = require('./get-indentation');\n\nmodule.exports = indentation;\n\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\n/* Remove the minimum indent from every line in `value`.\n * Supports both tab, spaced, and mixed indentation (as\n * well as possible). */\nfunction indentation(value, maximum) {\n  var values = value.split(C_NEWLINE);\n  var position = values.length + 1;\n  var minIndent = Infinity;\n  var matrix = [];\n  var index;\n  var indentation;\n  var stops;\n  var padding;\n\n  values.unshift(repeat(C_SPACE, maximum) + '!');\n\n  while (position--) {\n    indentation = getIndent(values[position]);\n\n    matrix[position] = indentation.stops;\n\n    if (trim(values[position]).length === 0) {\n      continue;\n    }\n\n    if (indentation.indent) {\n      if (indentation.indent > 0 && indentation.indent < minIndent) {\n        minIndent = indentation.indent;\n      }\n    } else {\n      minIndent = Infinity;\n\n      break;\n    }\n  }\n\n  if (minIndent !== Infinity) {\n    position = values.length;\n\n    while (position--) {\n      stops = matrix[position];\n      index = minIndent;\n\n      while (index && !(index in stops)) {\n        index--;\n      }\n\n      if (\n        trim(values[position]).length !== 0 &&\n        minIndent &&\n        index !== minIndent\n      ) {\n        padding = C_TAB;\n      } else {\n        padding = '';\n      }\n\n      values[position] = padding + values[position].slice(\n        index in stops ? stops[index] + 1 : 0\n      );\n    }\n  }\n\n  values.shift();\n\n  return values.join(C_NEWLINE);\n}\n"]},"metadata":{},"sourceType":"script"}