{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\n\nfunction factory(file) {\n  var contents = indices(String(file));\n  return {\n    toPosition: offsetToPositionFactory(contents),\n    toOffset: positionToOffsetFactory(contents)\n  };\n} // Factory to get the line and column-based `position` for `offset` in the bound\n// indices.\n\n\nfunction offsetToPositionFactory(indices) {\n  return offsetToPosition; // Get the line and column-based `position` for `offset` in the bound indices.\n\n  function offsetToPosition(offset) {\n    var index = -1;\n    var length = indices.length;\n\n    if (offset < 0) {\n      return {};\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        };\n      }\n    }\n\n    return {};\n  }\n} // Factory to get the `offset` for a line and column-based `position` in the\n// bound indices.\n\n\nfunction positionToOffsetFactory(indices) {\n  return positionToOffset; // Get the `offset` for a line and column-based `position` in the bound\n  // indices.\n\n  function positionToOffset(position) {\n    var line = position && position.line;\n    var column = position && position.column;\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0;\n    }\n\n    return -1;\n  }\n} // Get indices of line-breaks in `value`.\n\n\nfunction indices(value) {\n  var result = [];\n  var index = value.indexOf('\\n');\n\n  while (index !== -1) {\n    result.push(index + 1);\n    index = value.indexOf('\\n', index + 1);\n  }\n\n  result.push(value.length + 1);\n  return result;\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/vfile-location/index.js"],"names":["module","exports","factory","file","contents","indices","String","toPosition","offsetToPositionFactory","toOffset","positionToOffsetFactory","offsetToPosition","offset","index","length","line","column","positionToOffset","position","isNaN","value","result","indexOf","push"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,OAAjB;;AAEA,SAASA,OAAT,CAAiBC,IAAjB,EAAuB;AACrB,MAAIC,QAAQ,GAAGC,OAAO,CAACC,MAAM,CAACH,IAAD,CAAP,CAAtB;AAEA,SAAO;AACLI,IAAAA,UAAU,EAAEC,uBAAuB,CAACJ,QAAD,CAD9B;AAELK,IAAAA,QAAQ,EAAEC,uBAAuB,CAACN,QAAD;AAF5B,GAAP;AAID,C,CAED;AACA;;;AACA,SAASI,uBAAT,CAAiCH,OAAjC,EAA0C;AACxC,SAAOM,gBAAP,CADwC,CAGxC;;AACA,WAASA,gBAAT,CAA0BC,MAA1B,EAAkC;AAChC,QAAIC,KAAK,GAAG,CAAC,CAAb;AACA,QAAIC,MAAM,GAAGT,OAAO,CAACS,MAArB;;AAEA,QAAIF,MAAM,GAAG,CAAb,EAAgB;AACd,aAAO,EAAP;AACD;;AAED,WAAO,EAAEC,KAAF,GAAUC,MAAjB,EAAyB;AACvB,UAAIT,OAAO,CAACQ,KAAD,CAAP,GAAiBD,MAArB,EAA6B;AAC3B,eAAO;AACLG,UAAAA,IAAI,EAAEF,KAAK,GAAG,CADT;AAELG,UAAAA,MAAM,EAAEJ,MAAM,IAAIP,OAAO,CAACQ,KAAK,GAAG,CAAT,CAAP,IAAsB,CAA1B,CAAN,GAAqC,CAFxC;AAGLD,UAAAA,MAAM,EAAEA;AAHH,SAAP;AAKD;AACF;;AAED,WAAO,EAAP;AACD;AACF,C,CAED;AACA;;;AACA,SAASF,uBAAT,CAAiCL,OAAjC,EAA0C;AACxC,SAAOY,gBAAP,CADwC,CAGxC;AACA;;AACA,WAASA,gBAAT,CAA0BC,QAA1B,EAAoC;AAClC,QAAIH,IAAI,GAAGG,QAAQ,IAAIA,QAAQ,CAACH,IAAhC;AACA,QAAIC,MAAM,GAAGE,QAAQ,IAAIA,QAAQ,CAACF,MAAlC;;AAEA,QAAI,CAACG,KAAK,CAACJ,IAAD,CAAN,IAAgB,CAACI,KAAK,CAACH,MAAD,CAAtB,IAAkCD,IAAI,GAAG,CAAP,IAAYV,OAAlD,EAA2D;AACzD,aAAO,CAACA,OAAO,CAACU,IAAI,GAAG,CAAR,CAAP,IAAqB,CAAtB,IAA2BC,MAA3B,GAAoC,CAApC,IAAyC,CAAhD;AACD;;AAED,WAAO,CAAC,CAAR;AACD;AACF,C,CAED;;;AACA,SAASX,OAAT,CAAiBe,KAAjB,EAAwB;AACtB,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIR,KAAK,GAAGO,KAAK,CAACE,OAAN,CAAc,IAAd,CAAZ;;AAEA,SAAOT,KAAK,KAAK,CAAC,CAAlB,EAAqB;AACnBQ,IAAAA,MAAM,CAACE,IAAP,CAAYV,KAAK,GAAG,CAApB;AACAA,IAAAA,KAAK,GAAGO,KAAK,CAACE,OAAN,CAAc,IAAd,EAAoBT,KAAK,GAAG,CAA5B,CAAR;AACD;;AAEDQ,EAAAA,MAAM,CAACE,IAAP,CAAYH,KAAK,CAACN,MAAN,GAAe,CAA3B;AAEA,SAAOO,MAAP;AACD","sourcesContent":["'use strict'\n\nmodule.exports = factory\n\nfunction factory(file) {\n  var contents = indices(String(file))\n\n  return {\n    toPosition: offsetToPositionFactory(contents),\n    toOffset: positionToOffsetFactory(contents)\n  }\n}\n\n// Factory to get the line and column-based `position` for `offset` in the bound\n// indices.\nfunction offsetToPositionFactory(indices) {\n  return offsetToPosition\n\n  // Get the line and column-based `position` for `offset` in the bound indices.\n  function offsetToPosition(offset) {\n    var index = -1\n    var length = indices.length\n\n    if (offset < 0) {\n      return {}\n    }\n\n    while (++index < length) {\n      if (indices[index] > offset) {\n        return {\n          line: index + 1,\n          column: offset - (indices[index - 1] || 0) + 1,\n          offset: offset\n        }\n      }\n    }\n\n    return {}\n  }\n}\n\n// Factory to get the `offset` for a line and column-based `position` in the\n// bound indices.\nfunction positionToOffsetFactory(indices) {\n  return positionToOffset\n\n  // Get the `offset` for a line and column-based `position` in the bound\n  // indices.\n  function positionToOffset(position) {\n    var line = position && position.line\n    var column = position && position.column\n\n    if (!isNaN(line) && !isNaN(column) && line - 1 in indices) {\n      return (indices[line - 2] || 0) + column - 1 || 0\n    }\n\n    return -1\n  }\n}\n\n// Get indices of line-breaks in `value`.\nfunction indices(value) {\n  var result = []\n  var index = value.indexOf('\\n')\n\n  while (index !== -1) {\n    result.push(index + 1)\n    index = value.indexOf('\\n', index + 1)\n  }\n\n  result.push(value.length + 1)\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}