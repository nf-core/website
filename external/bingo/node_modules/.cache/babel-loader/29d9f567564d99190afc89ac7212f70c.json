{"ast":null,"code":"'use strict';\n\nmodule.exports = factory;\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n/* Check whether a node is mergeable with adjacent nodes. */\n\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n\n  return start.line !== end.line || end.column - start.column === node.value.length;\n}\n/* Merge two text nodes: `node` into `prev`. */\n\n\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n  return prev;\n}\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\n\n\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n  return prev;\n}\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\n\n\nfunction factory(type) {\n  return tokenize;\n  /* Tokenizer for a bound `type`. */\n\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n    /* Trim white space only lines. */\n\n    if (!value) {\n      return tokens;\n    }\n    /* Expose on `eat`. */\n\n\n    eat.now = now;\n    eat.file = self.file;\n    /* Sync initial offset. */\n\n    updatePosition('');\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (method && (\n        /* istanbul ignore next */\n        !method.onlyAtStart || self.atStart) && (!method.notInList || !self.inList) && (!method.notInBlock || !self.inBlock) && (!method.notInLink || !self.inLink)) {\n          valueLength = value.length;\n          method.apply(self, [eat, value]);\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n      /* istanbul ignore if */\n\n\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n    return tokens;\n    /* Update line, column, and offset based on\n     * `value`. */\n\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n\n\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n    /* Get the current position. */\n\n\n    function now() {\n      var pos = {\n        line: line,\n        column: column\n      };\n      pos.offset = self.toOffset(pos);\n      return pos;\n    }\n    /* Store position information for a node. */\n\n\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n\n\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(new Error('Incorrectly eaten value: please report this ' + 'warning on http://git.io/vg5Ft'), now());\n      }\n    }\n    /* Mark position and patch `node.position`. */\n\n\n    function position() {\n      var before = now();\n      return update;\n      /* Add the position to a node. */\n\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n        node.position = new Position(start);\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n        return node;\n      }\n    }\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n\n\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (prev && node.type === prev.type && node.type in MERGEABLE_NODES && mergeable(prev) && mergeable(node)) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n\n\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n      validateEat(subvalue);\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n      value = value.substring(subvalue.length);\n      updatePosition(subvalue);\n      indent = indent();\n      return apply;\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n\n\n      function reset() {\n        var node = apply.apply(null, arguments);\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return node;\n      }\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n\n\n      function test() {\n        var result = pos({});\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n        return result.position;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/tokenizer.js"],"names":["module","exports","factory","MERGEABLE_NODES","text","mergeText","blockquote","mergeBlockquote","mergeable","node","start","end","type","position","line","column","value","length","prev","options","commonmark","children","concat","tokenize","location","self","offset","tokens","methods","tokenizers","index","method","name","matched","valueLength","eat","now","file","updatePosition","onlyAtStart","atStart","notInList","inList","notInBlock","inBlock","notInLink","inLink","apply","fail","Error","eof","subvalue","lastIndex","indexOf","getOffset","indentation","pos","last","push","toOffset","Position","validateEat","substring","before","update","indent","combined","n","l","add","parent","call","exitStart","current","reset","test","arguments","result"],"mappings":"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","sourcesContent":["'use strict';\n\nmodule.exports = factory;\n\nvar MERGEABLE_NODES = {\n  text: mergeText,\n  blockquote: mergeBlockquote\n};\n\n/* Check whether a node is mergeable with adjacent nodes. */\nfunction mergeable(node) {\n  var start;\n  var end;\n\n  if (node.type !== 'text' || !node.position) {\n    return true;\n  }\n\n  start = node.position.start;\n  end = node.position.end;\n\n  /* Only merge nodes which occupy the same size as their\n   * `value`. */\n  return start.line !== end.line ||\n      end.column - start.column === node.value.length;\n}\n\n/* Merge two text nodes: `node` into `prev`. */\nfunction mergeText(prev, node) {\n  prev.value += node.value;\n\n  return prev;\n}\n\n/* Merge two blockquotes: `node` into `prev`, unless in\n * CommonMark mode. */\nfunction mergeBlockquote(prev, node) {\n  if (this.options.commonmark) {\n    return node;\n  }\n\n  prev.children = prev.children.concat(node.children);\n\n  return prev;\n}\n\n/* Construct a tokenizer.  This creates both\n * `tokenizeInline` and `tokenizeBlock`. */\nfunction factory(type) {\n  return tokenize;\n\n  /* Tokenizer for a bound `type`. */\n  function tokenize(value, location) {\n    var self = this;\n    var offset = self.offset;\n    var tokens = [];\n    var methods = self[type + 'Methods'];\n    var tokenizers = self[type + 'Tokenizers'];\n    var line = location.line;\n    var column = location.column;\n    var index;\n    var length;\n    var method;\n    var name;\n    var matched;\n    var valueLength;\n\n    /* Trim white space only lines. */\n    if (!value) {\n      return tokens;\n    }\n\n    /* Expose on `eat`. */\n    eat.now = now;\n    eat.file = self.file;\n\n    /* Sync initial offset. */\n    updatePosition('');\n\n    /* Iterate over `value`, and iterate over all\n     * tokenizers.  When one eats something, re-iterate\n     * with the remaining value.  If no tokenizer eats,\n     * something failed (should not happen) and an\n     * exception is thrown. */\n    while (value) {\n      index = -1;\n      length = methods.length;\n      matched = false;\n\n      while (++index < length) {\n        name = methods[index];\n        method = tokenizers[name];\n\n        if (\n          method &&\n          /* istanbul ignore next */ (!method.onlyAtStart || self.atStart) &&\n          (!method.notInList || !self.inList) &&\n          (!method.notInBlock || !self.inBlock) &&\n          (!method.notInLink || !self.inLink)\n        ) {\n          valueLength = value.length;\n\n          method.apply(self, [eat, value]);\n\n          matched = valueLength !== value.length;\n\n          if (matched) {\n            break;\n          }\n        }\n      }\n\n      /* istanbul ignore if */\n      if (!matched) {\n        self.file.fail(new Error('Infinite loop'), eat.now());\n      }\n    }\n\n    self.eof = now();\n\n    return tokens;\n\n    /* Update line, column, and offset based on\n     * `value`. */\n    function updatePosition(subvalue) {\n      var lastIndex = -1;\n      var index = subvalue.indexOf('\\n');\n\n      while (index !== -1) {\n        line++;\n        lastIndex = index;\n        index = subvalue.indexOf('\\n', index + 1);\n      }\n\n      if (lastIndex === -1) {\n        column += subvalue.length;\n      } else {\n        column = subvalue.length - lastIndex;\n      }\n\n      if (line in offset) {\n        if (lastIndex !== -1) {\n          column += offset[line];\n        } else if (column <= offset[line]) {\n          column = offset[line] + 1;\n        }\n      }\n    }\n\n    /* Get offset.  Called before the first character is\n     * eaten to retrieve the range's offsets. */\n    function getOffset() {\n      var indentation = [];\n      var pos = line + 1;\n\n      /* Done.  Called when the last character is\n       * eaten to retrieve the range’s offsets. */\n      return function () {\n        var last = line + 1;\n\n        while (pos < last) {\n          indentation.push((offset[pos] || 0) + 1);\n\n          pos++;\n        }\n\n        return indentation;\n      };\n    }\n\n    /* Get the current position. */\n    function now() {\n      var pos = {line: line, column: column};\n\n      pos.offset = self.toOffset(pos);\n\n      return pos;\n    }\n\n    /* Store position information for a node. */\n    function Position(start) {\n      this.start = start;\n      this.end = now();\n    }\n\n    /* Throw when a value is incorrectly eaten.\n     * This shouldn’t happen but will throw on new,\n     * incorrect rules. */\n    function validateEat(subvalue) {\n      /* istanbul ignore if */\n      if (value.substring(0, subvalue.length) !== subvalue) {\n        /* Capture stack-trace. */\n        self.file.fail(\n          new Error(\n            'Incorrectly eaten value: please report this ' +\n            'warning on http://git.io/vg5Ft'\n          ),\n          now()\n        );\n      }\n    }\n\n    /* Mark position and patch `node.position`. */\n    function position() {\n      var before = now();\n\n      return update;\n\n      /* Add the position to a node. */\n      function update(node, indent) {\n        var prev = node.position;\n        var start = prev ? prev.start : before;\n        var combined = [];\n        var n = prev && prev.end.line;\n        var l = before.line;\n\n        node.position = new Position(start);\n\n        /* If there was already a `position`, this\n         * node was merged.  Fixing `start` wasn’t\n         * hard, but the indent is different.\n         * Especially because some information, the\n         * indent between `n` and `l` wasn’t\n         * tracked.  Luckily, that space is\n         * (should be?) empty, so we can safely\n         * check for it now. */\n        if (prev && indent && prev.indent) {\n          combined = prev.indent;\n\n          if (n < l) {\n            while (++n < l) {\n              combined.push((offset[n] || 0) + 1);\n            }\n\n            combined.push(before.column);\n          }\n\n          indent = combined.concat(indent);\n        }\n\n        node.position.indent = indent || [];\n\n        return node;\n      }\n    }\n\n    /* Add `node` to `parent`s children or to `tokens`.\n     * Performs merges where possible. */\n    function add(node, parent) {\n      var children = parent ? parent.children : tokens;\n      var prev = children[children.length - 1];\n\n      if (\n        prev &&\n        node.type === prev.type &&\n        node.type in MERGEABLE_NODES &&\n        mergeable(prev) &&\n        mergeable(node)\n      ) {\n        node = MERGEABLE_NODES[node.type].call(self, prev, node);\n      }\n\n      if (node !== prev) {\n        children.push(node);\n      }\n\n      if (self.atStart && tokens.length !== 0) {\n        self.exitStart();\n      }\n\n      return node;\n    }\n\n    /* Remove `subvalue` from `value`.\n     * `subvalue` must be at the start of `value`. */\n    function eat(subvalue) {\n      var indent = getOffset();\n      var pos = position();\n      var current = now();\n\n      validateEat(subvalue);\n\n      apply.reset = reset;\n      reset.test = test;\n      apply.test = test;\n\n      value = value.substring(subvalue.length);\n\n      updatePosition(subvalue);\n\n      indent = indent();\n\n      return apply;\n\n      /* Add the given arguments, add `position` to\n       * the returned node, and return the node. */\n      function apply(node, parent) {\n        return pos(add(pos(node), parent), indent);\n      }\n\n      /* Functions just like apply, but resets the\n       * content:  the line and column are reversed,\n       * and the eaten value is re-added.\n       * This is useful for nodes with a single\n       * type of content, such as lists and tables.\n       * See `apply` above for what parameters are\n       * expected. */\n      function reset() {\n        var node = apply.apply(null, arguments);\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return node;\n      }\n\n      /* Test the position, after eating, and reverse\n       * to a not-eaten state. */\n      function test() {\n        var result = pos({});\n\n        line = current.line;\n        column = current.column;\n        value = subvalue + value;\n\n        return result.position;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}