{"ast":null,"code":"'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n  /* Exit when not in gfm-mode. */\n\n  if (!self.options.gfm) {\n    return;\n  }\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n\n\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n  /* Parse the alignment row. */\n\n\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n  /* Exit when without enough columns. */\n\n\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n  /* istanbul ignore if - never used (yet) */\n\n\n  if (silent) {\n    return true;\n  }\n  /* Parse the rows. */\n\n\n  position = -1;\n  rows = [];\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {\n      type: 'tableRow',\n      children: []\n    };\n    /* Eat a newline character when this is not the\n     * first row. */\n\n    if (position) {\n      eat(C_NEWLINE);\n    }\n    /* Eat the row. */\n\n\n    eat(line).reset(row, table);\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n    /* Eat the alignment row. */\n\n\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/nf-co.re/external/bingo/node_modules/remark-parse/lib/tokenize/table.js"],"names":["whitespace","require","module","exports","table","C_BACKSLASH","C_TICK","C_DASH","C_PIPE","C_COLON","C_SPACE","C_NEWLINE","C_TAB","MIN_TABLE_COLUMNS","MIN_TABLE_ROWS","TABLE_ALIGN_LEFT","TABLE_ALIGN_CENTER","TABLE_ALIGN_RIGHT","TABLE_ALIGN_NONE","eat","value","silent","self","index","alignments","alignment","subvalue","row","length","lines","queue","character","hasDash","align","cell","preamble","count","opening","now","position","lineCount","line","rows","lineIndex","pipeIndex","first","options","gfm","indexOf","push","slice","join","splice","charAt","reset","type","children","tokenizeInline"],"mappings":"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","sourcesContent":["'use strict';\n\nvar whitespace = require('is-whitespace-character');\n\nmodule.exports = table;\n\nvar C_BACKSLASH = '\\\\';\nvar C_TICK = '`';\nvar C_DASH = '-';\nvar C_PIPE = '|';\nvar C_COLON = ':';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\n\nvar MIN_TABLE_COLUMNS = 1;\nvar MIN_TABLE_ROWS = 2;\n\nvar TABLE_ALIGN_LEFT = 'left';\nvar TABLE_ALIGN_CENTER = 'center';\nvar TABLE_ALIGN_RIGHT = 'right';\nvar TABLE_ALIGN_NONE = null;\n\nfunction table(eat, value, silent) {\n  var self = this;\n  var index;\n  var alignments;\n  var alignment;\n  var subvalue;\n  var row;\n  var length;\n  var lines;\n  var queue;\n  var character;\n  var hasDash;\n  var align;\n  var cell;\n  var preamble;\n  var count;\n  var opening;\n  var now;\n  var position;\n  var lineCount;\n  var line;\n  var rows;\n  var table;\n  var lineIndex;\n  var pipeIndex;\n  var first;\n\n  /* Exit when not in gfm-mode. */\n  if (!self.options.gfm) {\n    return;\n  }\n\n  /* Get the rows.\n   * Detecting tables soon is hard, so there are some\n   * checks for performance here, such as the minimum\n   * number of rows, and allowed characters in the\n   * alignment row. */\n  index = 0;\n  lineCount = 0;\n  length = value.length + 1;\n  lines = [];\n\n  while (index < length) {\n    lineIndex = value.indexOf(C_NEWLINE, index);\n    pipeIndex = value.indexOf(C_PIPE, index + 1);\n\n    if (lineIndex === -1) {\n      lineIndex = value.length;\n    }\n\n    if (pipeIndex === -1 || pipeIndex > lineIndex) {\n      if (lineCount < MIN_TABLE_ROWS) {\n        return;\n      }\n\n      break;\n    }\n\n    lines.push(value.slice(index, lineIndex));\n    lineCount++;\n    index = lineIndex + 1;\n  }\n\n  /* Parse the alignment row. */\n  subvalue = lines.join(C_NEWLINE);\n  alignments = lines.splice(1, 1)[0] || [];\n  index = 0;\n  length = alignments.length;\n  lineCount--;\n  alignment = false;\n  align = [];\n\n  while (index < length) {\n    character = alignments.charAt(index);\n\n    if (character === C_PIPE) {\n      hasDash = null;\n\n      if (alignment === false) {\n        if (first === false) {\n          return;\n        }\n      } else {\n        align.push(alignment);\n        alignment = false;\n      }\n\n      first = false;\n    } else if (character === C_DASH) {\n      hasDash = true;\n      alignment = alignment || TABLE_ALIGN_NONE;\n    } else if (character === C_COLON) {\n      if (alignment === TABLE_ALIGN_LEFT) {\n        alignment = TABLE_ALIGN_CENTER;\n      } else if (hasDash && alignment === TABLE_ALIGN_NONE) {\n        alignment = TABLE_ALIGN_RIGHT;\n      } else {\n        alignment = TABLE_ALIGN_LEFT;\n      }\n    } else if (!whitespace(character)) {\n      return;\n    }\n\n    index++;\n  }\n\n  if (alignment !== false) {\n    align.push(alignment);\n  }\n\n  /* Exit when without enough columns. */\n  if (align.length < MIN_TABLE_COLUMNS) {\n    return;\n  }\n\n  /* istanbul ignore if - never used (yet) */\n  if (silent) {\n    return true;\n  }\n\n  /* Parse the rows. */\n  position = -1;\n  rows = [];\n\n  table = eat(subvalue).reset({\n    type: 'table',\n    align: align,\n    children: rows\n  });\n\n  while (++position < lineCount) {\n    line = lines[position];\n    row = {type: 'tableRow', children: []};\n\n    /* Eat a newline character when this is not the\n     * first row. */\n    if (position) {\n      eat(C_NEWLINE);\n    }\n\n    /* Eat the row. */\n    eat(line).reset(row, table);\n\n    length = line.length + 1;\n    index = 0;\n    queue = '';\n    cell = '';\n    preamble = true;\n    count = null;\n    opening = null;\n\n    while (index < length) {\n      character = line.charAt(index);\n\n      if (character === C_TAB || character === C_SPACE) {\n        if (cell) {\n          queue += character;\n        } else {\n          eat(character);\n        }\n\n        index++;\n        continue;\n      }\n\n      if (character === '' || character === C_PIPE) {\n        if (preamble) {\n          eat(character);\n        } else {\n          if (character && opening) {\n            queue += character;\n            index++;\n            continue;\n          }\n\n          if ((cell || character) && !preamble) {\n            subvalue = cell;\n\n            if (queue.length > 1) {\n              if (character) {\n                subvalue += queue.slice(0, queue.length - 1);\n                queue = queue.charAt(queue.length - 1);\n              } else {\n                subvalue += queue;\n                queue = '';\n              }\n            }\n\n            now = eat.now();\n\n            eat(subvalue)({\n              type: 'tableCell',\n              children: self.tokenizeInline(cell, now)\n            }, row);\n          }\n\n          eat(queue + character);\n\n          queue = '';\n          cell = '';\n        }\n      } else {\n        if (queue) {\n          cell += queue;\n          queue = '';\n        }\n\n        cell += character;\n\n        if (character === C_BACKSLASH && index !== length - 2) {\n          cell += line.charAt(index + 1);\n          index++;\n        }\n\n        if (character === C_TICK) {\n          count = 1;\n\n          while (line.charAt(index + 1) === character) {\n            cell += character;\n            index++;\n            count++;\n          }\n\n          if (!opening) {\n            opening = count;\n          } else if (count >= opening) {\n            opening = 0;\n          }\n        }\n      }\n\n      preamble = false;\n      index++;\n    }\n\n    /* Eat the alignment row. */\n    if (!position) {\n      eat(C_NEWLINE + alignments);\n    }\n  }\n\n  return table;\n}\n"]},"metadata":{},"sourceType":"script"}