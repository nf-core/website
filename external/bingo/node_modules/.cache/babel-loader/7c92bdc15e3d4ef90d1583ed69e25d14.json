{"ast":null,"code":"'use strict';\n/* eslint-disable max-params */\n\nvar trim = require('trim');\n\nvar repeat = require('repeat-string');\n\nvar decimal = require('is-decimal');\n\nvar getIndent = require('../util/get-indentation');\n\nvar removeIndent = require('../util/remove-indentation');\n\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n/* Map of characters which can be used to mark\n * list-items. */\n\nvar LIST_UNORDERED_MARKERS = {};\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_MARKERS = {};\nLIST_ORDERED_MARKERS[C_DOT] = true;\n/* Map of characters which can be used to mark\n * list-items after a digit. */\n\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - size % TAB_SIZE;\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n  markers = commonmark ? LIST_ORDERED_COMMONMARK_MARKERS : LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - size % TAB_SIZE;\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - size % TAB_SIZE;\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (currentMarker === C_ASTERISK || currentMarker === C_UNDERSCORE || currentMarker === C_DASH) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n  node.loose = isLoose;\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) || value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n/* Create a list-item using overly simple mechanics. */\n\n\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n\n  line = position.line;\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n    return '';\n  }\n}\n/* Create a list-item using sane mechanics. */\n\n\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n  /* Remove the list-item’s bullet. */\n\n  value = value.replace(EXPRESSION_BULLET, replacer);\n  lines = value.split(C_NEWLINE);\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n\n  trimmedLines[0] = rest;\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) + lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n    return max + rest;\n  }\n}","map":{"version":3,"sources":["/home/jfellows/Documents/git/jfy133/bingo/node_modules/remark-parse/lib/tokenize/list.js"],"names":["trim","require","repeat","decimal","getIndent","removeIndent","interrupt","module","exports","list","C_ASTERISK","C_UNDERSCORE","C_PLUS","C_DASH","C_DOT","C_SPACE","C_NEWLINE","C_TAB","C_PAREN_CLOSE","C_X_LOWER","TAB_SIZE","EXPRESSION_LOOSE_LIST_ITEM","EXPRESSION_TASK_ITEM","EXPRESSION_BULLET","EXPRESSION_PEDANTIC_BULLET","EXPRESSION_INITIAL_INDENT","LIST_UNORDERED_MARKERS","LIST_ORDERED_MARKERS","LIST_ORDERED_COMMONMARK_MARKERS","eat","value","silent","self","commonmark","options","pedantic","tokenizers","blockTokenizers","interuptors","interruptList","markers","index","length","start","size","queue","ordered","character","marker","nextIndex","startIndex","prefixed","currentMarker","content","line","prevEmpty","empty","items","allLines","emptyLines","item","enterTop","exitBlockquote","isLoose","node","now","end","indented","charAt","parseInt","indexOf","indent","slice","thematicBreak","call","concat","push","trail","join","reset","type","loose","children","enterList","enterBlock","listItem","ctx","position","offsets","offset","fn","pedanticListItem","normalListItem","checked","task","apply","arguments","gfm","match","toLowerCase","test","tokenizeBlock","replace","replacer","$0","max","bullet","rest","lines","trimmedLines","split","$1","$2","$3","$4","Number"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable max-params */\n\nvar trim = require('trim');\nvar repeat = require('repeat-string');\nvar decimal = require('is-decimal');\nvar getIndent = require('../util/get-indentation');\nvar removeIndent = require('../util/remove-indentation');\nvar interrupt = require('../util/interrupt');\n\nmodule.exports = list;\n\nvar C_ASTERISK = '*';\nvar C_UNDERSCORE = '_';\nvar C_PLUS = '+';\nvar C_DASH = '-';\nvar C_DOT = '.';\nvar C_SPACE = ' ';\nvar C_NEWLINE = '\\n';\nvar C_TAB = '\\t';\nvar C_PAREN_CLOSE = ')';\nvar C_X_LOWER = 'x';\n\nvar TAB_SIZE = 4;\nvar EXPRESSION_LOOSE_LIST_ITEM = /\\n\\n(?!\\s*$)/;\nvar EXPRESSION_TASK_ITEM = /^\\[([ \\t]|x|X)][ \\t]/;\nvar EXPRESSION_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])( {1,4}(?! )| |\\t|$|(?=\\n))([^\\n]*)/;\nvar EXPRESSION_PEDANTIC_BULLET = /^([ \\t]*)([*+-]|\\d+[.)])([ \\t]+)/;\nvar EXPRESSION_INITIAL_INDENT = /^( {1,4}|\\t)?/gm;\n\n/* Map of characters which can be used to mark\n * list-items. */\nvar LIST_UNORDERED_MARKERS = {};\n\nLIST_UNORDERED_MARKERS[C_ASTERISK] = true;\nLIST_UNORDERED_MARKERS[C_PLUS] = true;\nLIST_UNORDERED_MARKERS[C_DASH] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_MARKERS = {};\n\nLIST_ORDERED_MARKERS[C_DOT] = true;\n\n/* Map of characters which can be used to mark\n * list-items after a digit. */\nvar LIST_ORDERED_COMMONMARK_MARKERS = {};\n\nLIST_ORDERED_COMMONMARK_MARKERS[C_DOT] = true;\nLIST_ORDERED_COMMONMARK_MARKERS[C_PAREN_CLOSE] = true;\n\nfunction list(eat, value, silent) {\n  var self = this;\n  var commonmark = self.options.commonmark;\n  var pedantic = self.options.pedantic;\n  var tokenizers = self.blockTokenizers;\n  var interuptors = self.interruptList;\n  var markers;\n  var index = 0;\n  var length = value.length;\n  var start = null;\n  var size = 0;\n  var queue;\n  var ordered;\n  var character;\n  var marker;\n  var nextIndex;\n  var startIndex;\n  var prefixed;\n  var currentMarker;\n  var content;\n  var line;\n  var prevEmpty;\n  var empty;\n  var items;\n  var allLines;\n  var emptyLines;\n  var item;\n  var enterTop;\n  var exitBlockquote;\n  var isLoose;\n  var node;\n  var now;\n  var end;\n  var indented;\n\n  while (index < length) {\n    character = value.charAt(index);\n\n    if (character === C_TAB) {\n      size += TAB_SIZE - (size % TAB_SIZE);\n    } else if (character === C_SPACE) {\n      size++;\n    } else {\n      break;\n    }\n\n    index++;\n  }\n\n  if (size >= TAB_SIZE) {\n    return;\n  }\n\n  character = value.charAt(index);\n\n  markers = commonmark ?\n    LIST_ORDERED_COMMONMARK_MARKERS :\n    LIST_ORDERED_MARKERS;\n\n  if (LIST_UNORDERED_MARKERS[character] === true) {\n    marker = character;\n    ordered = false;\n  } else {\n    ordered = true;\n    queue = '';\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (!decimal(character)) {\n        break;\n      }\n\n      queue += character;\n      index++;\n    }\n\n    character = value.charAt(index);\n\n    if (!queue || markers[character] !== true) {\n      return;\n    }\n\n    start = parseInt(queue, 10);\n    marker = character;\n  }\n\n  character = value.charAt(++index);\n\n  if (character !== C_SPACE && character !== C_TAB) {\n    return;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  index = 0;\n  items = [];\n  allLines = [];\n  emptyLines = [];\n\n  while (index < length) {\n    nextIndex = value.indexOf(C_NEWLINE, index);\n    startIndex = index;\n    prefixed = false;\n    indented = false;\n\n    if (nextIndex === -1) {\n      nextIndex = length;\n    }\n\n    end = index + TAB_SIZE;\n    size = 0;\n\n    while (index < length) {\n      character = value.charAt(index);\n\n      if (character === C_TAB) {\n        size += TAB_SIZE - (size % TAB_SIZE);\n      } else if (character === C_SPACE) {\n        size++;\n      } else {\n        break;\n      }\n\n      index++;\n    }\n\n    if (size >= TAB_SIZE) {\n      indented = true;\n    }\n\n    if (item && size >= item.indent) {\n      indented = true;\n    }\n\n    character = value.charAt(index);\n    currentMarker = null;\n\n    if (!indented) {\n      if (LIST_UNORDERED_MARKERS[character] === true) {\n        currentMarker = character;\n        index++;\n        size++;\n      } else {\n        queue = '';\n\n        while (index < length) {\n          character = value.charAt(index);\n\n          if (!decimal(character)) {\n            break;\n          }\n\n          queue += character;\n          index++;\n        }\n\n        character = value.charAt(index);\n        index++;\n\n        if (queue && markers[character] === true) {\n          currentMarker = character;\n          size += queue.length + 1;\n        }\n      }\n\n      if (currentMarker) {\n        character = value.charAt(index);\n\n        if (character === C_TAB) {\n          size += TAB_SIZE - (size % TAB_SIZE);\n          index++;\n        } else if (character === C_SPACE) {\n          end = index + TAB_SIZE;\n\n          while (index < end) {\n            if (value.charAt(index) !== C_SPACE) {\n              break;\n            }\n\n            index++;\n            size++;\n          }\n\n          if (index === end && value.charAt(index) === C_SPACE) {\n            index -= TAB_SIZE - 1;\n            size -= TAB_SIZE - 1;\n          }\n        } else if (character !== C_NEWLINE && character !== '') {\n          currentMarker = null;\n        }\n      }\n    }\n\n    if (currentMarker) {\n      if (!pedantic && marker !== currentMarker) {\n        break;\n      }\n\n      prefixed = true;\n    } else {\n      if (!commonmark && !indented && value.charAt(startIndex) === C_SPACE) {\n        indented = true;\n      } else if (commonmark && item) {\n        indented = size >= item.indent || size > TAB_SIZE;\n      }\n\n      prefixed = false;\n      index = startIndex;\n    }\n\n    line = value.slice(startIndex, nextIndex);\n    content = startIndex === index ? line : value.slice(index, nextIndex);\n\n    if (\n      currentMarker === C_ASTERISK ||\n      currentMarker === C_UNDERSCORE ||\n      currentMarker === C_DASH\n    ) {\n      if (tokenizers.thematicBreak.call(self, eat, line, true)) {\n        break;\n      }\n    }\n\n    prevEmpty = empty;\n    empty = !trim(content).length;\n\n    if (indented && item) {\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (prefixed) {\n      if (emptyLines.length !== 0) {\n        item.value.push('');\n        item.trail = emptyLines.concat();\n      }\n\n      item = {\n        value: [line],\n        indent: size,\n        trail: []\n      };\n\n      items.push(item);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    } else if (empty) {\n      if (prevEmpty) {\n        break;\n      }\n\n      emptyLines.push(line);\n    } else {\n      if (prevEmpty) {\n        break;\n      }\n\n      if (interrupt(interuptors, tokenizers, self, [eat, line, true])) {\n        break;\n      }\n\n      item.value = item.value.concat(emptyLines, line);\n      allLines = allLines.concat(emptyLines, line);\n      emptyLines = [];\n    }\n\n    index = nextIndex + 1;\n  }\n\n  node = eat(allLines.join(C_NEWLINE)).reset({\n    type: 'list',\n    ordered: ordered,\n    start: start,\n    loose: null,\n    children: []\n  });\n\n  enterTop = self.enterList();\n  exitBlockquote = self.enterBlock();\n  isLoose = false;\n  index = -1;\n  length = items.length;\n\n  while (++index < length) {\n    item = items[index].value.join(C_NEWLINE);\n    now = eat.now();\n\n    item = eat(item)(listItem(self, item, now), node);\n\n    if (item.loose) {\n      isLoose = true;\n    }\n\n    item = items[index].trail.join(C_NEWLINE);\n\n    if (index !== length - 1) {\n      item += C_NEWLINE;\n    }\n\n    eat(item);\n  }\n\n  enterTop();\n  exitBlockquote();\n\n  node.loose = isLoose;\n\n  return node;\n}\n\nfunction listItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var fn = ctx.options.pedantic ? pedanticListItem : normalListItem;\n  var checked = null;\n  var task;\n  var indent;\n\n  value = fn.apply(null, arguments);\n\n  if (ctx.options.gfm) {\n    task = value.match(EXPRESSION_TASK_ITEM);\n\n    if (task) {\n      indent = task[0].length;\n      checked = task[1].toLowerCase() === C_X_LOWER;\n      offsets[position.line] += indent;\n      value = value.slice(indent);\n    }\n  }\n\n  return {\n    type: 'listItem',\n    loose: EXPRESSION_LOOSE_LIST_ITEM.test(value) ||\n      value.charAt(value.length - 1) === C_NEWLINE,\n    checked: checked,\n    children: ctx.tokenizeBlock(value, position)\n  };\n}\n\n/* Create a list-item using overly simple mechanics. */\nfunction pedanticListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_PEDANTIC_BULLET, replacer);\n\n  /* The initial line was also matched by the below, so\n   * we reset the `line`. */\n  line = position.line;\n\n  return value.replace(EXPRESSION_INITIAL_INDENT, replacer);\n\n  /* A simple replacer which removed all matches,\n   * and adds their length to `offset`. */\n  function replacer($0) {\n    offsets[line] = (offsets[line] || 0) + $0.length;\n    line++;\n\n    return '';\n  }\n}\n\n/* Create a list-item using sane mechanics. */\nfunction normalListItem(ctx, value, position) {\n  var offsets = ctx.offset;\n  var line = position.line;\n  var max;\n  var bullet;\n  var rest;\n  var lines;\n  var trimmedLines;\n  var index;\n  var length;\n\n  /* Remove the list-item’s bullet. */\n  value = value.replace(EXPRESSION_BULLET, replacer);\n\n  lines = value.split(C_NEWLINE);\n\n  trimmedLines = removeIndent(value, getIndent(max).indent).split(C_NEWLINE);\n\n  /* We replaced the initial bullet with something\n   * else above, which was used to trick\n   * `removeIndentation` into removing some more\n   * characters when possible.  However, that could\n   * result in the initial line to be stripped more\n   * than it should be. */\n  trimmedLines[0] = rest;\n\n  offsets[line] = (offsets[line] || 0) + bullet.length;\n  line++;\n\n  index = 0;\n  length = lines.length;\n\n  while (++index < length) {\n    offsets[line] = (offsets[line] || 0) +\n      lines[index].length - trimmedLines[index].length;\n    line++;\n  }\n\n  return trimmedLines.join(C_NEWLINE);\n\n  function replacer($0, $1, $2, $3, $4) {\n    bullet = $1 + $2 + $3;\n    rest = $4;\n\n    /* Make sure that the first nine numbered list items\n     * can indent with an extra space.  That is, when\n     * the bullet did not receive an extra final space. */\n    if (Number($2) < 10 && bullet.length % 2 === 1) {\n      $2 = C_SPACE + $2;\n    }\n\n    max = $1 + repeat(C_SPACE, $2.length) + $3;\n\n    return max + rest;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}