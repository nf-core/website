---
import PageLayout from "@layouts/PageLayout.astro";

// Handle pipelines.json import with fallback
let pipelinesData: any = { remote_workflows: [] };
try {
    // @ts-ignore - Dynamic import may fail if file doesn't exist
    const module = await import("@public/pipelines.json");
    pipelinesData = module.default || module;
} catch (e) {
    console.log("pipelines.json not found, using empty data");
}

// Flatten the pipelines data into a more usable format
const pipelineVersions: {
    pipeline: string;
    release: string;
    nextflow_version: string | null;
    nf_core_version: string | null;
    published_at: string | null;
    published_date: Date | null;
}[] = [];
const workflows = pipelinesData?.remote_workflows || [];

// Filter out archived pipelines
const activeWorkflows = workflows.filter((workflow: any) => !workflow.archived);

activeWorkflows.forEach((workflow: any) => {
    const pipelineName = workflow.name;
    const releases = workflow.releases || [];

    releases.forEach((release: any) => {
        pipelineVersions.push({
            pipeline: pipelineName,
            release: release.tag_name,
            nextflow_version: release.nextflow_version || null,
            nf_core_version: release.nf_core_version || null,
            published_at: release.published_at || null,
            published_date: release.published_at ? new Date(release.published_at) : null,
        });
    });
});

// Sort by pipeline name, then by release (dev last)
pipelineVersions.sort((a, b) => {
    if (a.pipeline !== b.pipeline) {
        return a.pipeline.localeCompare(b.pipeline);
    }
    if (a.release === "dev" && b.release !== "dev") return -1;
    if (a.release !== "dev" && b.release === "dev") return 1;
    // Sort by published date for numbered releases (newest first)
    if (a.published_date && b.published_date) {
        return b.published_date.getTime() - a.published_date.getTime();
    }
    return 0;
});

// Identify latest release for each pipeline (excluding dev)
const latestReleases = new Map<string, string>();
pipelineVersions.forEach((version) => {
    if (version.release !== "dev" && !latestReleases.has(version.pipeline)) {
        latestReleases.set(version.pipeline, version.release);
    }
});

// Calculate statistics
const totalPipelines = activeWorkflows.length;
const totalReleases = pipelineVersions.length;

// Count Nextflow versions (only from latest releases)
const nextflowVersionCounts: Record<string, number> = {};
const nextflowVersionCountsAll: Record<string, number> = {};
pipelineVersions.forEach((p) => {
    if (p.nextflow_version) {
        const version = p.nextflow_version.replace("!>=", ">=");
        // Count all versions
        nextflowVersionCountsAll[version] = (nextflowVersionCountsAll[version] || 0) + 1;
        // Only count if it's the latest release for this pipeline
        if (p.release === latestReleases.get(p.pipeline)) {
            nextflowVersionCounts[version] = (nextflowVersionCounts[version] || 0) + 1;
        }
    }
});

// Count nf-core versions (only from latest releases)
const nfCoreVersionCounts: Record<string, number> = {};
const nfCoreVersionCountsAll: Record<string, number> = {};
pipelineVersions.forEach((p) => {
    // Use "<2.14.1" for missing versions
    const version = p.nf_core_version || "<2.14.1";
    // Count all versions
    nfCoreVersionCountsAll[version] = (nfCoreVersionCountsAll[version] || 0) + 1;
    // Only count if it's the latest release for this pipeline
    if (p.release === latestReleases.get(p.pipeline)) {
        nfCoreVersionCounts[version] = (nfCoreVersionCounts[version] || 0) + 1;
    }
});

// Format date
const formatDate = (dateStr: string | null) => {
    if (!dateStr) return "-";
    const date = new Date(dateStr);
    return date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short",
        day: "numeric",
    });
};

// Prepare data for histograms
const prepareChartData = (versionCounts: Record<string, number>) => {
    const entries = Object.entries(versionCounts);

    const labels = entries.map(([version]) => version);
    const values = entries.map(([, count]) => count);

    return { labels, values };
};

const nextflowChartData = prepareChartData(nextflowVersionCounts);
const nfCoreChartData = prepareChartData(nfCoreVersionCounts);

// Generate histogram
const createBarChart = (
    data: { labels: string[]; values: number[] },
    accentColor: string = "#23a3dd",
    chartId: string,
) => {
    if (data.labels.length === 0) return "";

    // Sort data by version number (descending) by default
    const sortedData = data.labels
        .map((label, i) => ({
            label,
            value: data.values[i],
            version: label.match(/[\d.]+/)?.[0] || "",
        }))
        .sort((a, b) => {
            // Handle "<2.14.1" specially - it should come first (oldest)
            if (a.label.startsWith("<") && !b.label.startsWith("<")) return 1; // a goes to end (oldest)
            if (!a.label.startsWith("<") && b.label.startsWith("<")) return -1; // b goes to end (oldest)

            // Extract version numbers for proper sorting
            const aParts = a.version.split(".").map(Number);
            const bParts = b.version.split(".").map(Number);
            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                const aPart = aParts[i] || 0;
                const bPart = bParts[i] || 0;
                if (aPart !== bPart) {
                    return bPart - aPart; // Descending order
                }
            }
            return 0;
        });

    // Create table-based bar chart
    const maxValue = Math.max(...data.values);
    const rows = sortedData
        .map(({ label, value }) => {
            const percentage = (value / maxValue) * 100;
            return `
            <tr data-version="${label}" data-count="${value}">
                <td class="chart-label text-nowrap pe-2">${label.replace(">=", "&ge; ").replace("≥", "&ge; ")}</td>
                <td class="w-100">
                    <div class="chart-bar" style="width: ${percentage}%; background-color: ${accentColor};">
                        <span class="text-white ps-1">${value}</span>
                    </div>
                </td>
            </tr>
        `;
        })
        .join("");

    return `
        <table class="w-100 text-small histogram-table" id="${chartId}" data-initial-sort="version">
            <thead>
                <tr>
                    <th class="sortable histogram-sortable sort-asc" data-sort="version" style="width: 90px;">
                        Version
                        <i class="fas fa-sort ms-1 text-muted"></i>
                    </th>
                    <th class="sortable histogram-sortable" data-sort="count">
                        Count
                        <i class="fas fa-sort ms-1 text-muted"></i>
                    </th>
                </tr>
            </thead>
            <tbody>${rows}</tbody>
        </table>
    `;
};

const nextflowChart = createBarChart(nextflowChartData, "var(--bs-info)", "nextflowChart");
const nfCoreChart = createBarChart(nfCoreChartData, "var(--bs-warning)", "nfCoreChart");
---

<PageLayout
    title="Pipeline Versions"
    subtitle="Nextflow and nf-core tools versions across all pipelines"
    mainpage_container={false}
>
    <div class="container main-content">
        {
            pipelineVersions.length === 0 ? (
                <div class="alert alert-info" role="alert">
                    <h4 class="alert-heading">No version data available</h4>
                    <p>
                        The version information file has not been generated yet. This data is updated nightly by an
                        automated workflow.
                    </p>
                    <hr />
                    <p class="mb-0">
                        <a
                            href="https://github.com/nf-core/website/actions/workflows/update-version-info.yml"
                            class="btn btn-sm btn-primary"
                            target="_blank"
                        >
                            View Update Workflow
                        </a>
                    </p>
                </div>
            ) : (
                <>
                    {/* Version Distribution Charts */}
                    <div class="row g-3 mb-4">
                        <div class="col-lg-6">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">Nextflow Version Distribution</h5>
                                    <p class="text-muted small mb-3">(latest releases only)</p>
                                    <div set:html={nextflowChart} />
                                </div>
                            </div>
                        </div>
                        <div class="col-lg-6">
                            <div class="card h-100">
                                <div class="card-body">
                                    <h5 class="card-title">nf-core Tools Version Distribution</h5>
                                    <p class="text-muted small my-2">(latest releases only)</p>
                                    <div set:html={nfCoreChart} />
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Versions Table */}
                    <div class="mb-3 d-flex justify-content-between align-items-center">
                        <div class="btn-group" role="group">
                            <button type="button" class="btn btn-sm btn-primary" id="toggleReleases">
                                <i class="fas fa-eye me-1" />
                                <span class="toggle-text">Show all releases</span>
                            </button>
                            <button type="button" class="btn btn-sm btn-outline-primary" id="downloadCSV">
                                <i class="fas fa-download me-1" />
                                Download CSV
                            </button>
                        </div>
                        <span class="text-muted small">
                            Showing {totalPipelines} latest releases
                            <span class="hidden-count">({totalReleases - totalPipelines} hidden)</span>
                        </span>
                    </div>
                    <table class="table table-hover table-sm text-small" id="versionsTable">
                        <thead>
                            <tr class="sticky-top-under z-1 table-active">
                                <th class="sortable sort-desc" data-sort="pipeline">
                                    Pipeline
                                    <i class="fas fa-sort ms-1 text-muted" />
                                </th>
                                <th class="sortable" data-sort="release">
                                    Release
                                    <i class="fas fa-sort ms-1 text-muted" />
                                </th>
                                <th class="sortable" data-sort="nextflow">
                                    Nextflow Version
                                    <i class="fas fa-sort ms-1 text-muted" />
                                </th>
                                <th class="sortable" data-sort="nfcore">
                                    nf-core Version
                                    <i class="fas fa-sort ms-1 text-muted" />
                                </th>
                                <th class="sortable" data-sort="date">
                                    Published Date
                                    <i class="fas fa-sort ms-1 text-muted" />
                                </th>
                            </tr>
                        </thead>
                        <tbody>
                            {pipelineVersions.map((version) => {
                                const isLatest = version.release === latestReleases.get(version.pipeline);
                                const isDev = version.release === "dev";
                                const showByDefault = isLatest || (isDev && !latestReleases.has(version.pipeline));
                                const isNonLatestNonDev = !isLatest && !isDev;
                                return (
                                    <tr
                                        class:list={[{ "hidden-release": !showByDefault }]}
                                        data-pipeline={version.pipeline}
                                        data-release={version.release}
                                        data-nextflow={version.nextflow_version || ""}
                                        data-nfcore={version.nf_core_version || ""}
                                        data-date={version.published_at || ""}
                                    >
                                        <td class="fw-semibold">
                                            <a
                                                href={`https://nf-co.re/${version.pipeline}`}
                                                target="_blank"
                                                class:list={[
                                                    "text-decoration-none",
                                                    { "text-body-tertiary": isNonLatestNonDev },
                                                ]}
                                            >
                                                {version.pipeline}
                                            </a>
                                        </td>
                                        <td>
                                            {version.release === "dev" ? (
                                                <span class="badge bg-secondary">{version.release}</span>
                                            ) : (
                                                <a
                                                    href={`https://github.com/nf-core/${version.pipeline}/releases/tag/${version.release}`}
                                                    target="_blank"
                                                    class:list={[
                                                        "text-decoration-none",
                                                        { "text-body-tertiary": isNonLatestNonDev },
                                                    ]}
                                                >
                                                    {version.release}
                                                </a>
                                            )}
                                        </td>
                                        <td>
                                            {version.nextflow_version ? (
                                                <code class:list={[{ "text-body-tertiary": isNonLatestNonDev }]}>
                                                    {version.nextflow_version.replace("!>=", "≥")}
                                                </code>
                                            ) : (
                                                <span class="text-muted">-</span>
                                            )}
                                        </td>
                                        <td>
                                            {version.nf_core_version ? (
                                                <code class:list={[{ "text-body-tertiary": isNonLatestNonDev }]}>
                                                    v{version.nf_core_version}
                                                </code>
                                            ) : (
                                                <code
                                                    class:list={[
                                                        "text-muted",
                                                        { "text-body-tertiary": isNonLatestNonDev },
                                                    ]}
                                                >
                                                    &lt;2.14.1
                                                </code>
                                            )}
                                        </td>
                                        <td
                                            class:list={[
                                                "text-muted small",
                                                { "text-body-tertiary": isNonLatestNonDev },
                                            ]}
                                        >
                                            {formatDate(version.published_at)}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>

                    <div class="text-center mt-4 mb-5">
                        <p class="text-muted">
                            Data last updated from <code>pipelines.json</code>
                        </p>
                        <a
                            href="https://github.com/nf-core/website/actions/workflows/update-pipelines-json.yml"
                            class="btn btn-sm btn-outline-primary"
                            target="_blank"
                        >
                            View Update Workflow
                        </a>
                    </div>
                </>
            )
        }
    </div>
</PageLayout>

<style>
    .hidden-release {
        display: none;
    }

    .show-all .hidden-release {
        display: table-row;
    }

    /* Custom bar chart styling */
    .chart-label {
        width: 90px;
        text-align: right;
    }

    .chart-bar {
        display: inline-block;
        min-width: 30px;
        text-align: center;
        border-radius: 3px;
    }

    /* Histogram table styling */
    .histogram-table thead th {
        font-size: 0.875rem;
        padding: 0.5rem 0.75rem;
        border-bottom: 2px solid var(--bs-border-color);
    }

    .histogram-table tbody td {
        padding: 0.25rem 0.75rem;
        vertical-align: middle;
    }

    /* Sortable table headers */
    .sortable {
        cursor: pointer;
        user-select: none;
        white-space: nowrap;
    }

    .sortable i {
        font-size: 0.75rem;
        transition: opacity 0.2s;
        opacity: 0.5;
    }

    .sortable:hover i {
        opacity: 1;
    }

    :global(.sortable.sort-asc i::before) {
        content: "\f0de"; /* fa-sort-up */
        opacity: 1;
    }

    :global(.sortable.sort-desc i::before) {
        content: "\f0dd"; /* fa-sort-down */
        opacity: 1;
    }
</style>

<script>
    document.addEventListener("DOMContentLoaded", () => {
        // Initialize toggle functionality
        const toggleButton = document.getElementById("toggleReleases");
        const downloadButton = document.getElementById("downloadCSV");
        const versionsTable = document.getElementById("versionsTable") as HTMLTableElement;
        const toggleText = toggleButton?.querySelector(".toggle-text");
        const toggleIcon = toggleButton?.querySelector("i");
        const hiddenCount = document.querySelector(".hidden-count") as HTMLElement;

        let showingAll = false;

        toggleButton?.addEventListener("click", () => {
            showingAll = !showingAll;

            if (showingAll) {
                versionsTable?.classList.add("show-all");
                if (toggleText) toggleText.textContent = "Show latest only";
                toggleIcon?.classList.remove("fa-eye");
                toggleIcon?.classList.add("fa-eye-slash");
                if (hiddenCount) hiddenCount.style.display = "none";
            } else {
                versionsTable?.classList.remove("show-all");
                if (toggleText) toggleText.textContent = "Show all releases";
                toggleIcon?.classList.remove("fa-eye-slash");
                toggleIcon?.classList.add("fa-eye");
                if (hiddenCount) hiddenCount.style.display = "inline";
            }
        });

        // Download CSV functionality
        downloadButton?.addEventListener("click", () => {
            const rows = versionsTable?.querySelectorAll("tbody tr");
            if (!rows) return;

            // CSV header
            let csv = "Pipeline,Release,Nextflow Version,nf-core Version,Published Date\n";

            // Add data rows (including hidden ones based on current view)
            rows.forEach((row) => {
                // Skip hidden rows if not showing all
                if (!showingAll && row.classList.contains("hidden-release")) {
                    return;
                }

                const cells = row.querySelectorAll("td");
                const pipeline = cells[0]?.textContent?.trim() || "";
                const release = cells[1]?.textContent?.trim() || "";
                const nextflowVersion = cells[2]?.textContent?.trim().replace("≥", ">=") || "";
                let nfCoreVersion = cells[3]?.textContent?.trim() || "";
                // Replace the HTML entity with the actual character for CSV
                if (nfCoreVersion.includes("<")) {
                    nfCoreVersion = nfCoreVersion.replace(/</g, "gs<");
                }
                const publishedDate = cells[4]?.textContent?.trim() || "";

                // Escape values that contain commas or quotes
                const escapeCSV = (value: string) => {
                    if (value.includes(",") || value.includes('"') || value.includes("\n")) {
                        return `"${value.replace(/"/g, '""')}"`;
                    }
                    return value;
                };

                csv += `${escapeCSV(pipeline)},${escapeCSV(release)},${escapeCSV(nextflowVersion)},${escapeCSV(nfCoreVersion)},${escapeCSV(publishedDate)}\n`;
            });

            // Create and trigger download
            const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);

            const timestamp = new Date().toISOString().split("T")[0];
            const filename = showingAll
                ? `nf-core-pipeline-versions-all-${timestamp}.csv`
                : `nf-core-pipeline-versions-latest-${timestamp}.csv`;

            link.setAttribute("href", url);
            link.setAttribute("download", filename);
            link.style.visibility = "hidden";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // Initialize table sorting
        const sortableHeaders = versionsTable?.querySelectorAll<HTMLTableCellElement>("th.sortable");
        let currentSort: { column: string; ascending: boolean } | null = null;

        sortableHeaders?.forEach((header) => {
            header.addEventListener("click", () => {
                const sortType = header.dataset.sort;
                if (!sortType) return;

                // Determine sort direction
                const isAscending = currentSort?.column === sortType ? !currentSort.ascending : true;
                currentSort = { column: sortType, ascending: isAscending };

                // Update header classes
                sortableHeaders.forEach((h) => {
                    h.classList.remove("sort-asc", "sort-desc");
                });
                header.classList.add(isAscending ? "sort-asc" : "sort-desc");

                // Sort the table
                sortTable(sortType, isAscending);
            });
        });

        function sortTable(sortType: string, ascending: boolean) {
            const tbody = versionsTable?.querySelector("tbody");
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll("tr"));

            // Custom sorting function
            rows.sort((a, b) => {
                let aValue = a.dataset[sortType] || "";
                let bValue = b.dataset[sortType] || "";

                // Special handling for different column types
                switch (sortType) {
                    case "date":
                        // Sort by date (ISO format)
                        aValue = aValue || "0000-00-00";
                        bValue = bValue || "0000-00-00";
                        break;
                    case "release":
                        // Put 'dev' releases at the end when ascending, start when descending
                        if (aValue === "dev" && bValue !== "dev") return ascending ? 1 : -1;
                        if (aValue !== "dev" && bValue === "dev") return ascending ? -1 : 1;
                        // Try to sort numerically if possible (for version numbers)
                        const aNum = parseFloat(aValue.replace(/[^0-9.]/g, ""));
                        const bNum = parseFloat(bValue.replace(/[^0-9.]/g, ""));
                        if (!isNaN(aNum) && !isNaN(bNum)) {
                            return ascending ? aNum - bNum : bNum - aNum;
                        }
                        break;
                    case "nextflow":
                    case "nfcore":
                        // Extract version numbers for proper sorting
                        const aVersion = aValue.match(/[\d.]+/)?.[0] || "";
                        const bVersion = bValue.match(/[\d.]+/)?.[0] || "";
                        if (aVersion && bVersion) {
                            const aParts = aVersion.split(".").map(Number);
                            const bParts = bVersion.split(".").map(Number);
                            for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                                const aPart = aParts[i] || 0;
                                const bPart = bParts[i] || 0;
                                if (aPart !== bPart) {
                                    return ascending ? aPart - bPart : bPart - aPart;
                                }
                            }
                        }
                        break;
                }

                // Default string comparison
                const comparison = aValue.localeCompare(bValue);
                return ascending ? comparison : -comparison;
            });

            // Re-append rows in sorted order
            rows.forEach((row) => tbody.appendChild(row));
        }

        // Initialize histogram table sorting
        const histogramTables = document.querySelectorAll(".histogram-table");
        histogramTables.forEach((table) => {
            const headers = table.querySelectorAll<HTMLTableCellElement>("th.histogram-sortable");
            // Initialize with version sorted ascending by default
            let currentHistogramSort: { column: string; ascending: boolean } | null = {
                column: "version",
                ascending: true,
            };

            headers.forEach((header) => {
                header.addEventListener("click", () => {
                    const sortType = header.dataset.sort;
                    if (!sortType) return;

                    // Determine sort direction
                    const isAscending =
                        currentHistogramSort?.column === sortType ? !currentHistogramSort.ascending : true;
                    currentHistogramSort = { column: sortType, ascending: isAscending };

                    // Update header classes
                    headers.forEach((h) => {
                        h.classList.remove("sort-asc", "sort-desc");
                    });
                    header.classList.add(isAscending ? "sort-asc" : "sort-desc");

                    // Sort the histogram table
                    sortHistogramTable(table as HTMLTableElement, sortType, isAscending);
                });
            });
        });

        function sortHistogramTable(table: HTMLTableElement, sortType: string, ascending: boolean) {
            const tbody = table.querySelector("tbody");
            if (!tbody) return;

            const rows = Array.from(tbody.querySelectorAll("tr"));

            rows.sort((a, b) => {
                let aValue: string | number = a.dataset[sortType] || "";
                let bValue: string | number = b.dataset[sortType] || "";

                if (sortType === "count") {
                    // Convert to numbers for count sorting
                    aValue = parseInt(aValue as string) || 0;
                    bValue = parseInt(bValue as string) || 0;
                    return ascending
                        ? (aValue as number) - (bValue as number)
                        : (bValue as number) - (aValue as number);
                } else {
                    // Version sorting - handle "<2.14.1" specially
                    const aIsLessThan = (aValue as string).startsWith("<");
                    const bIsLessThan = (bValue as string).startsWith("<");

                    if (aIsLessThan && !bIsLessThan) {
                        return ascending ? -1 : 1; // "<2.14.1" is oldest
                    }
                    if (!aIsLessThan && bIsLessThan) {
                        return ascending ? 1 : -1; // "<2.14.1" is oldest
                    }

                    // Extract numeric parts for regular versions
                    const aVersion = (aValue as string).match(/[\d.]+/)?.[0] || "";
                    const bVersion = (bValue as string).match(/[\d.]+/)?.[0] || "";

                    if (aVersion && bVersion) {
                        const aParts = aVersion.split(".").map(Number);
                        const bParts = bVersion.split(".").map(Number);
                        for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
                            const aPart = aParts[i] || 0;
                            const bPart = bParts[i] || 0;
                            if (aPart !== bPart) {
                                return ascending ? aPart - bPart : bPart - aPart;
                            }
                        }
                    }

                    // Fallback to string comparison
                    const comparison = (aValue as string).localeCompare(bValue as string);
                    return ascending ? comparison : -comparison;
                }
            });

            // Re-append rows in sorted order
            rows.forEach((row) => tbody.appendChild(row));
        }
    });
</script>
