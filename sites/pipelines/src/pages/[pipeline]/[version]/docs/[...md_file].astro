---
import MarkdownWrapper from "@components/markdown/MarkdownWrapper.svelte";
import SidebarToc from "@components/sidebar/SidebarToc.svelte";
import SidebarNav from "@components/sidebar/SidebarNav.astro";
import PipelinePageLayout from "@layouts/PipelinePageLayout.astro";
import pipelines_json from "@public/pipelines.json";
import { getEntry } from "astro:content";
import type { SidebarEntry } from "@utils/types";
import { createLinkOrGroup, addEntriesToSection as addEntriesToSectionBase } from "@utils/functions";

import ExpandDetailsButton from "@components/sidebar/ExpandDetailsButton.svelte";

export async function getStaticPaths() {
    let paths: {
        params: { pipeline: string; version: string; md_file: string };
        props: { versions: string[]; md_files: { slug: string; data?: any }[]; description: string | null };
    }[] = [];

    await Promise.all(
        pipelines_json.remote_workflows.map(async (pipeline) => {
            const releases = pipeline.releases;
            const extended_releases = [...releases, { tag_name: "latest", doc_files: releases[0].doc_files }];

            await Promise.all(
                extended_releases.map(async (release) => {
                    // Get collection entries for all files
                    const entries = await Promise.all(
                        release.doc_files.map((file) =>
                            getEntry(
                                "pipelines",
                                `${pipeline.name}/${release.tag_name}/${file.replace(".md", "").toLowerCase()}`,
                            ),
                        ),
                    );
                    const md_files = entries.some((entry) => !entry)
                        ? release.doc_files.map((file) => ({
                              slug: file.replace("docs/", "").replace(".mdx", "").replace(".md", ""),
                              data: {},
                          }))
                        : entries.map((entry) => {
                              return {
                                  slug: entry?.slug
                                      .replace(`${pipeline.name}/${release.tag_name}/`, "")
                                      .replace("docs/", "")
                                      .replace(".mdx", "")
                                      .replace(".md", ""),
                                  data: entry?.data,
                              };
                          });

                    md_files.forEach((md_file) => {
                        paths.push({
                            params: { pipeline: pipeline.name, version: release.tag_name, md_file: md_file.slug },
                            props: {
                                versions: releases.map((r) => r.tag_name),
                                md_files: md_files.filter((f) => f.slug),
                                description: pipeline.description,
                            },
                        });
                    });
                }),
            );
        }),
    );

    return paths;
}
let { pipeline, version, md_file } = Astro.params;
const { versions, md_files, description } = Astro.props;

const section = md_file.split("/")[0];
// check if there are multiple files in the section
let leftSidebar = md_files.filter((file) => file.slug.split("/")[0] === section).length > 1;

let sections: SidebarEntry[] = [];

// add trailing slash to url if missing
let url = Astro.url.pathname.endsWith("/") ? Astro.url.pathname : Astro.url.pathname + "/";
url = url.replace(/\.html\/$/, "/");
// drop everything after docs/
if (leftSidebar) {
    // Convert md_files to match the expected CollectionEntry<'docs'> structure
    const docsEntries = md_files
        .filter((f) => f.slug.startsWith(section))
        .map((file) => {
            return {
                slug: `${file.slug}`,
                data: {
                    weight: file.data?.order,
                    shortTitle: file.data?.shortTitle,
                },
            };
        });
    addEntriesToSectionBase(sections, docsEntries, `${Astro.url.pathname}`, `/${pipeline}/${version}/docs/`);
    // if there is only one section, expand it, same for the children
    if (sections.length === 1 && sections[0].type === "group") {
        sections[0].collapsed = false;
        if (sections[0].entries.length === 1 && sections[0].entries[0].type === "group") {
            sections[0].entries.forEach((entry) => {
                if (entry.type === "group") {
                    entry.collapsed = false;
                }
            });
        }
    }
    // Add book icons to all group entries
    const addBookIcons = (entries: SidebarEntry[]) => {
        entries.forEach((entry) => {
            if (entry.type === "group") {
                entry.icon = "fa-regular fa-book";
                if (entry.entries) {
                    addBookIcons(entry.entries);
                }
            }
        });
    };

    addBookIcons(sections);
}
const version_tag_name = version === "latest" ? versions[0] : version;
const cache_key = `${pipeline}/${version_tag_name?.replaceAll(".", "")}/docs/${md_file?.toLowerCase()}`;

const entry = await getEntry("pipelines", cache_key);
if (!entry) {
    return Astro.redirect("/404");
}
let { Content, headings } = await entry.render();
const max_heading_depth = 2;

// filter out headings that are higher than max_heading_depth
headings = headings.filter((h) => h.depth <= max_heading_depth);
---

<PipelinePageLayout
    pipeline={pipeline}
    meta_title={pipeline +
        ": " +
        section.replace(/-/g, " ").replace(/\w\S*/g, (w) => w.replace(/^\w/, (c) => c.toUpperCase()))}
    subtitle={description}
    headings={headings}
    version={version}
    versions={versions}
    tabItems={md_files.map((file) => file.slug)}
    md_github_url={`https://github.com/nf-core/${pipeline}/blob/${version}/docs/${md_file}.md`}
    sections={sections}
    docSearchTags={[
        { name: "page_rank", content: "5" },
        { name: "page_subtype", content: "docs" },
    ]}
>
    <div class="row">
        {
            leftSidebar && (
                <div class="col-12 col-md-2 sticky-top-under d-none d-md-inline sidebar-left pt-3">
                    <SidebarNav items={sections} />
                </div>
            )
        }
        <div class:list={["col-12 pt-3 markdown-content", { "col-md-9": !leftSidebar, "col-md-8": leftSidebar }]}>
            <MarkdownWrapper client:load headings={headings}>
                <Content />
            </MarkdownWrapper>
        </div>
        <div class:list={["col-12 toc", { "col-md-3": !leftSidebar, "col-md-2": leftSidebar }]}>
            <SidebarToc headings={headings} client:idle><ExpandDetailsButton client:idle /></SidebarToc>
        </div>
    </div>
</PipelinePageLayout>
<style>
    /* center all images */
    :global(p img) {
        display: block;
        margin: 0 auto;
    }
</style>
